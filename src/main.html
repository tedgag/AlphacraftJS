<!DOCTYPE html>
<html>
<head>
<title>HTML Rasterizer</title>
</head>
<body>
<canvas id="canvas" width="350" height="350" style="border: 1px grey solid">
  <script>
    //------------------------------------------------------------------------//
    //                                 Enums                                  //
    //------------------------------------------------------------------------//
    const colors = {
      RED : [255, 0, 0],
      GREEN : [0, 255, 0],
      BLUE : [0, 0, 255],
      YELLOW : [255, 255, 0],
      PURPLE : [255, 0, 255],
      CYAN : [0, 255, 255],
      INDIGO : [75,0,130],
      WHITE : [255,255,255],
      GREY : [80,80,80],
      LIGHTGREY : [120,120,120],
      BLACK : [0,0,0],
      ORANGE : [255,165,0]
    }
    const lightType = {
      AMBIENT : "ambient",
      POINT : "point",
      DIRECTIONAL : "directional"
    }
   

  
    //------------------------------------------------------------------------//
    //                                Classes                                 //
    //------------------------------------------------------------------------//
    class Vertex {
      constructor(x,y,z=0,w=1) {
        this.x=x;
        this.y=y;
        this.z=z;
        this.w=w;
      }
      toString() {
        return "<" + this.x + ", " + this.y + ", " + this.z + ", " + this.w ;
      }
      toArray() {
        return [this.x,this.y,this.z,this.w];
      }
      toRGBA() {
        return [
          this.x * 255,
          this.y * 255,
          this.z * 255,
          this.w * 255
        ]
      }
    }
    class Mat {
      constructor(values) {
        this.values = values;
      }
    }
    class Canvas {
      constructor(canvas) {
        this.element = canvas;
        this.context=canvas.getContext("2d");
        this.buffer= this.context.getImageData(0, 0, canvas.width, canvas.height);
        this.pitch = this.buffer.width * 4;
        this.width = canvas.width;
        this.height= canvas.height;
      }
    }
    class Triangle {
      constructor(indices, normals, UVs, color, texture) {
        this.indices = indices;
        this.normals = normals;
        this.UVs = UVs;
        this.color = color;
        this.texture=texture;
      }
    }
    class Scene {
      constructor(instances, camera, lights) {
        this.instances = instances;
        this.camera = camera;
        this.lights =  lights;
      }
    }
    class Model {
      constructor(name,vertices,triangles, boundingSphere) {
        this.name=name;
        this.vertices=vertices;
        this.triangles=triangles;
      }
    }
    class Instance {
      constructor(model,position,rotation,scaling,reflectivity, children) {
        this.model=model;
        this.position = position;
        this.rotation = rotation;
        this.scaling = scaling;
        this.reflectivity = reflectivity;
        this.children = children;
        this.boundingSphere = new BoundingSphere(this.position, 0);
        this.colorShift = new Vertex (0,0,0);
      }
    
      translate (vector) {
        this.position.x += vector.x;
        this.position.y += vector.y;
        this.position.z += vector.z;
      }
      rotate (vector) {
        this.rotation.x += vector.x;
        this.rotation.y += vector.y;
        this.rotation.z += vector.z;
      }
      getBoundingSphere(vertices) {
        
        var highestX = vertices[0].x;
        var lowestX = vertices[0].x;
        var highestY = vertices[0].y;
        var lowestY = vertices[0].y;
        var highestZ = vertices[0].z;
        var lowestZ = vertices[0].z;
        for (let v of vertices) {
          if (v.x > highestX) {
            highestX = v.x;
          }
          if (v.x < lowestX) {
            lowestX = v.x;
          }
          if (v.y > highestY) {
            highestY = v.y;
          }
          if (v.y < lowestY) {
            lowestY = v.y;
          }
          if (v.z > highestZ) {
            highestZ = v.z;
          }
          if (v.z < lowestZ) {
            lowestZ = v.z;
          }
        }
        
        var mid = new Vertex((highestX+lowestX)/2,(highestY+lowestY)/2,(highestZ+lowestZ)/2);
    
        var radius=0;
        for (let v of vertices) {
          let d = distance(mid,v);
          if(d>radius) {
            radius=d;
          }
        }
        this.boundingSphere = new BoundingSphere(mid,radius);
        return this.boundingSphere;
      }
    }
    class Camera {
      constructor(position, orientation, clippingPlanes) {
        this.position = position;
        this.orientation = orientation;
        this.clippingPlanes = clippingPlanes
      }
      translate (vector) {
        this.position.x += vector.x;
        this.position.y += vector.y;
        this.position.z += vector.z;
      }
    }
    class Plane {
      constructor(normal, distance) {
        this.normal = normal;
        // distance from origin to plane. Same thing as D in plane equation.
        this.distance = distance;
      }
    }
    class BoundingSphere {
      constructor(position,radius) {
        this.position = position;
        this.radius = radius;
      }
    }
    class Light {
      constructor(type, intensity, position, direction, color = vertexFromRGBA(colors.WHITE)) {
        this.type = type;
        this.intensity = intensity;
        this.position = position;
        this.direction = direction;
        this.color = color;
      }
      translate (vector) {
        this.position.x += vector.x;
        this.position.y += vector.y;
        this.position.z += vector.z;
      }
    }
    class Texture{
      constructor(source) {
        this.image = new Image();

        var texture = this;
        this.image.addEventListener('load', function() {
          texture.iw = texture.image.width;
          texture.ih = texture.image.height;

          texture.canvas = document.createElement("canvas");
          texture.canvas.width = texture.iw;
          texture.canvas.height = texture.ih;
          var ctx = texture.canvas.getContext("2d");
          ctx.drawImage(texture.image, 0, 0, texture.iw, texture.ih);
          texture.pixel_data = ctx.getImageData(0, 0, texture.iw, texture.ih);
        }, false);

        this.image.src = source;
      }
      getTexel(u, v) {
        var iu = parseInt(u*this.iw);
        var iv = parseInt(v*this.ih);

        var offset = (iv*this.iw*4 + iu*4);

        return new Vertex(
          this.pixel_data.data[offset + 0]/255,
          this.pixel_data.data[offset + 1]/255,
          this.pixel_data.data[offset + 2]/255
        );
      }
    }
    class GameEntity {
      constructor(name, instance, light, hp) {
        this.name = name;
        this.instance = instance;
        this.light = light;
        this.hp = hp;
      }
    }
    
    
    //------------------------------------------------------------------------//
    //                            Canvas Data                                 //
    //------------------------------------------------------------------------//
    // Main screen canvas
    var main = document.getElementById("canvas");
    //main.style.width = "500px";
    //main.style.height = "500px";
    var mainCanvas = new Canvas(main );

    // First Offscreen canvas

    var offScreen1 = document.createElement('canvas');
    offScreen1.width = main.width;
    offScreen1.height = main.width;
    var offScreenFrontCanvas = new Canvas(offScreen1);

    // Second Offscreen canvas

    var offScreen2 = document.createElement('canvas');
    offScreen2.width = main.width;
    offScreen2.height = main.width;
    var offScreenBackCanvas = new Canvas(offScreen2);

    //Viewport info
    var viewportWidth = 1;
    var viewportHeight = 1;

    // Distance between near plane and origin
    var zProjectionPlane = 1;
    // To store depth of pixels to be drawn
    var depthBuffer = new Array(canvas.width * canvas.height);

    function putPixel(x, y, color, canvas) {
      x = canvas.width/2 + Math.floor(x);
      y = canvas.height/2 - Math.floor(y) - 1;
      if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
        return;
      }
      var offset = 4*x + canvas.pitch*y;
      canvas.buffer.data[offset++] = parseInt(color[0]);
      canvas.buffer.data[offset++] = parseInt(color[1]);
      canvas.buffer.data[offset++] = parseInt(color[2]);
      canvas.buffer.data[offset++] = 255;
    }
    function updateCanvas(canvas) {
      canvas.context.putImageData(canvas.buffer, 0, 0);
    }
    function clearBuffers(canvas) {
      canvas.context.fillStyle = "#202020";
      canvas.context.fillRect(0, 0, canvas.width, canvas.height);
      canvas.buffer = canvas.context.getImageData(0, 0, canvas.width, canvas.height);
      depthBuffer = new Array(canvas.width * canvas.height);
    }
    //------------------------------------------------------------------------//
    //                     Linear algebra and helpers                         //
    //------------------------------------------------------------------------//
    function add(v1, v2) {
      return new Vertex(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);
    }
    function subtract(v1, v2) {
      return new Vertex(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
    }
    // Multiply a vector by a scalar
    function multiply(s,v) {
      return new Vertex(s*v.x, s*v.y, s*v.z);
    }
    // Dot product between two vectors
    function dotProduct(vec1, vec2) {
      return vec1.x*vec2.x + vec1.y * vec2.y + vec1.z * vec2.z;
    }
    // Cross product between two vectors
    function crossProduct(vec1, vec2) {
      let i = vec1.y * vec2.z - vec1.z * vec2.y;
      let j = vec1.x * vec2.z - vec1.z * vec2.x;
      let k = vec1.x * vec2.y - vec1.y * vec2.x;
      return new Vertex(i, -j, k);
    }
    // Distance between two points.
    function distance(p1,p2) {
      let d = Math.pow(p2.x-p1.x,2) + Math.pow(p2.y-p1.y,2)
      if (p1.z && p2.z) {
        d += Math.pow(p2.z-p1.z,2)
      }
      return Math.sqrt(d);
    }
    
    // Mid point between two points.
    function midVertex(p1,p2) {
      let x = parseInt((p1.x+p2.x)/2);
      let y = parseInt((p1.y+p2.y)/2);
      if (p1.z && p2.z) {
        let z = parseInt((p1.z+p2.z)/2);
        return new Vertex(x,y,z);
      } else {
        return new Vertex(x,y);
      }
    }

    // Return the transpose of the given matrix
    function transpose(mat) {
      let result = [];
      let values = mat.values;
      for (let i=0;i<values.length;i++) {
        result[i]=[];
        for (let j=0;j<values[0].length;j++) {
          result[i][j]=values[j][i];
        }
      }
      return new Mat(result);
    }
    // Multiply a matrix by a vector.
    function multiplyMV(mat,vec) {
      let v = vec.toArray();
      if (mat.values[0].length!=v.length) {
        return null;
      }

      let result=[];
      for (let i=0;i<v.length;i++) {
        result.push(0);
      }
      let values = mat.values;

      for (let i=0; i<values.length; i++) {
        for (let j=0; j<values[i].length; j++) {
          result[i] += values[i][j] * v[j];
        }
      }
      return result;
    }
    // Multiply a matrix by another matrix
    function multiplyMM(mat1,mat2) {
      mat1Data = mat1.values;
      mat2Data = mat2.values;
      if (mat1Data[0].length!=mat2Data.length) {
        return null;
      }
      let result = [];
      for (let i=0;i<mat1Data.length;i++) {
        result[i]=[];
        for (let j=0;j<mat2Data[0].length;j++) {
          result[i][j]=0;
        }
      }
      for (let i=0; i<mat1Data.length; i++) {
        for (let j=0; j<mat2Data[i].length; j++){
          let dot=0;
          for (let k=0; k<mat1Data[i].length; k++){
            dot+= mat1Data[i][k] * mat2Data[k][j];
          }
          result[i][j] = dot;
        }
      }
      return new Mat(result);
    }
    function arrayToVertex(array) {
      return new Vertex(array[0], array[1], array[2]);
    }
    function interpolate(x0,y0,x1,y1) {
      if (x0==x1){
        return [ y0 ];
      }
      var values = [];
      var a = (y1-y0) / (x1-x0);
      var y = y0;
      for (let i = x0; i <= x1; i++) {
        values.push(y);
        y=y+a;
      }
      return values;
    }
    function interpolateEdges(x0,y0,x1,y1,x2,y2) {
      var y01 = interpolate(x0,y0,x1,y1);
      var y12 = interpolate(x1,y1,x2,y2);
      var y02 = interpolate(x0,y0,x2,y2);
      y01.pop();
      var y012 = y01.concat(y12);
      return [y02, y012];
    }
    // Get the normal of a triangle
    function getTriangleNormal(v0,v1,v2){
      let v01 = subtract(v1, v0);
      let v02 = subtract(v2, v0);
      return crossProduct(v01,v02);
    }
    // Find the centroid of a triangle
    function getCentroid(v0,v1,v2) {
      return multiply(1/3, add(add(v0, v1), v2));
    }
    // Find the point where the line defined by a and b intersect the plane
    function planeIntersection(a,b, plane) {
      let bMinusA = subtract(a, b);
      let num = - plane.distance - dotProduct(plane.normal, a);
      let denum = dotProduct(plane.normal, bMinusA);
      let t = num/denum;
      let q =  add(a, multiply(t, bMinusA));
      return [q, t];
    }
    // Compute the value of an attribute at t
    function computeAttribute(alphaA,alphaB,t) {
      return add(alphaA, multiply(t, subtract(alphaA, alphaB)));
    }
    function sortIndices(indices, vertices) {
      var i0 = 0;
      var i1 = 1; 
      var i2 = 2;
      // p0.y <= p1.y <= p2.y
      if (vertices[indices[i1]].y < vertices[indices[i0]].y) { 
        var i = i0; 
        i0 = i1; 
        i1 = i; 
      }
      if (vertices[indices[i2]].y < vertices[indices[i0]].y) { 
        var i = i0; 
        i0 = i2; 
        i2 = i; 
      }
      if (vertices[indices[i2]].y < vertices[indices[i1]].y) { 
        var i = i1; 
        i1 = i2; 
        i2 = i; 
      }
      return [i0,i1,i2];
    }
    function vectorLength(vec) {
      return Math.sqrt(Math.pow(vec.x, 2) + Math.pow(vec.y,2) + Math.pow(vec.z, 2));
    }
    function clamp(value) {
      if (value < 0) { return 0; }
      if (value > 1) { return 1; }
      return value;
    }
    function multiplyColors(color1, color2) {
      let r = clamp(color1.x * color2.x);
      let g = clamp(color1.y * color2.y);
      let b = clamp(color1.z * color2.z);
      let a = clamp(color1.w * color2.w);
      return new Vertex(r,g,b,a);
    }
    function addColors(color1, color2) {
      let r = color1.x + color2.x;
      let g = clamp(color1.y + color2.y);
      let b = clamp(color1.z + color2.z);
      let a = clamp(color1.w + color2.w);
      return new Vertex(r,g,b,a);
    }
    function toRad(angle) {
      return angle*Math.PI/180;
    }
    function toDeg(angle) {
      return angle*180/Math.PI;
    }
    function toUV(vertex) {
      let v = multiply(0.5, add(vertex, new Vertex(1,0,1)));
      return new Vertex(v.x,v.z);
    }
    function vertexFromRGBA(color) {
      if (colors.length == 4) {
        return new Vertex(color[0]/255, color[1]/255, color[2]/255, color[3]/255);
      } else {
        return new Vertex(color[0]/255, color[1]/255, color[2]/255, 1);
      }
    }
    //------------------------------------------------------------------------//
    //                        Transformation Matrices                         //
    //------------------------------------------------------------------------//

    // Translation matrix to the given position vector
    function makeTranslationMatrix(position) {
      let m = [
        [1,0,0,position.x],
        [0,1,0,position.y],
        [0,0,1,position.z],
        [0,0,0,1]
      ];
      return new Mat(m);
    }
    // Scale matrix for the given scaling vector
    function makeScaleMatrix(scaling) {
      let m = [
        [scaling.x,0,0,0],
        [0,scaling.y,0,0],
        [0,0,scaling.z,0],
        [0,0,0,1]
      ];
      return new Mat(m);
    }
    // Rotation matrix around x by the given angle (in degrees)
    function makeXRotationMatrix(angle) {
      let a = toRad(angle);
      let m = [
        [1,0,0,0],
        [0,Math.cos(a),-Math.sin(a),0],
        [0,Math.sin(a),Math.cos(a),0],
        [0,0,0,1]
      ];
      return new Mat(m);
    }
    // Rotation matrix around y by the given angle (in degrees)
    function makeYRotationMatrix(angle) {
      let a = toRad(angle);
      let m = [
        [Math.cos(a),0,Math.sin(a),0],
        [0,1,0,0],
        [-Math.sin(a),0,Math.cos(a),0],
        [0,0,0,1]
      ];
      return new Mat(m);
    }
    // Rotation matrix around z by the given angle (in degrees)
    function makeZRotationMatrix(angle) {
      let a = toRad(angle);
      let m = [
        [Math.cos(a),-Math.sin(a),0,0],
        [Math.sin(a),Math.cos(a),0,0],
        [0,0,1,0],
        [0,0,0,1]
      ];
      return new Mat(m);
    }
    function makeRotationMatrix(orientation) {
      let yRotationMat = makeYRotationMatrix(orientation.y);
      let xRotationMat = makeXRotationMatrix(orientation.x);
      let zRotationMat = makeZRotationMatrix(orientation.z);
      return multiplyMM(xRotationMat, multiplyMM(yRotationMat, zRotationMat));
    }
    function makeTransformMatrix(translationMat, rotationMat, scaleMat) {
        let mat = multiplyMM(rotationMat,scaleMat);
        return multiplyMM(translationMat,mat);
      }
    function makeCameraMatrix(camera) {
      let rotationMat = transpose(makeRotationMatrix(camera.orientation));
      let translationMat = makeTranslationMatrix(multiply(-1,camera.position));
      return multiplyMM(rotationMat,translationMat);
    }
    
    //------------------------------------------------------------------------//
    //                               Clipping                                 //
    //------------------------------------------------------------------------//
    // Checks if the bounding sphere is inside the view frustum defined by the camera.
    function checkForClipping(sphere, camera) {
      for (let p of camera.clippingPlanes) {
        let d = dotProduct(p.normal, sphere.position) + p.distance;
        if (d < -sphere.radius) {
          return true;
        }
      }
      return false;
    }
    // Clip the individual triangles in the model.
    function clipModel(model, plane) {
      var newTriangles = [];
      var newVertices = model.vertices;
      for (let triangle of model.triangles) {
        let iIn = [];
        let iOut = [];
        let indices = triangle.indices;
        for (let i = 0; i<indices.length; i++) {
          let v = newVertices[indices[i]];
          if (dotProduct(plane.normal, v) + plane.distance > 0) {
            iIn.push(i);
          } else {
            iOut.push(i);
          }
        }
        if (iIn.length == 0) {
          // Do nothing
        } else if (iIn.length == 3) {
          newTriangles.push(triangle);
        } else if (iIn.length == 1) {
          // Compute plane intersections between A and C and B and C
          let A = newVertices[indices[iIn[0]]];
          let B = newVertices[indices[iOut[0]]];
          let C = newVertices[indices[iOut[1]]];
          let [q1, t1] = planeIntersection(A,B, plane);
          let [q2, t2] = planeIntersection(A,C, plane);
          // Compute new indices
          let newIndices = [];
          newIndices[iIn[0]] = newVertices.length;
          newVertices.push(q1);
          newIndices[iOut[0]] = newVertices.length;
          newVertices.push(q2);
          newIndices[iOut[1]] = indices[iIn[0]];
          // Compute new UVs
          let newUVs = [];
          newUVs[iIn[0]] = triangle.UVs[iIn[0]];
          newUVs[iOut[0]] = computeAttribute(triangle.UVs[iIn[0]],triangle.UVs[iOut[0]], t1);
          newUVs[iOut[1]] = computeAttribute(triangle.UVs[iIn[0]],triangle.UVs[iOut[1]], t2);
          newTriangles.push(new Triangle(newIndices, triangle.normals,newUVs, triangle.color, triangle.texture));
        } else if (iIn.length == 2) {
          let [q1, t1] = planeIntersection(newVertices[indices[iIn[0]]],newVertices[indices[iOut[0]]], plane);
          // Compute new indices for 1st triangle
          let newIndices1 = [];
          let newIndices2 = [];
          newIndices1[iOut[0]] = newVertices.length;
          newIndices2[iOut[0]] = newVertices.length;
          newVertices.push(q1);
          newIndices1[iIn[0]] = indices[iIn[0]];
          newIndices1[iIn[1]] = indices[iIn[1]];
           // Compute new UVs for 1st triangle
          let newUVs1 = [];
          newUVs1[iIn[0]] = triangle.UVs[iIn[0]];
          newUVs1[iIn[1]] = triangle.UVs[iIn[1]];
          newUVs1[iOut[0]] = computeAttribute(triangle.UVs[iIn[0]],triangle.UVs[iOut[0]], t1);
          newTriangles.push(new Triangle(newIndices1, triangle.normals, newUVs1, triangle.color, triangle.texture));
          
          let [q2, t2] = planeIntersection(newVertices[indices[iIn[1]]],newVertices[indices[iOut[0]]], plane); 

          // Compute new indices for 2nd triangle
          newIndices2[iIn[1]] = newVertices.length;
          newVertices.push(q2);
          newIndices2[iIn[0]] = indices[iIn[1]];
          // Compute new UVs for 2nd triangle
          let newUVs2 = [];
          newUVs2[iIn[0]] = triangle.UVs[iIn[1]];
          newUVs2[iIn[1]] = computeAttribute(triangle.UVs[iIn[1]],triangle.UVs[iOut[0]], t2);
          newUVs2[iOut[0]] = computeAttribute(triangle.UVs[iIn[0]],triangle.UVs[iOut[0]], t2);
          newTriangles.push(new Triangle(newIndices2, triangle.normals, newUVs2, triangle.color, triangle.texture));
          
        }
      }
      
      return new Model(model.name, newVertices, newTriangles);
    }
    //------------------------------------------------------------------------//
    //                        Hidden surfaces removal                         //
    //------------------------------------------------------------------------//

    function updateDepthBuffer(x, y, zInv, canvas) {
      var x = canvas.width/2 + parseInt(x);
      var y = canvas.height/2 - parseInt(y) - 1;
     
      if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
        return false;
      }
      
      var offset = x + canvas.width*y;
      var data = depthBuffer[offset];
      if (data == undefined || data < zInv) {
        depthBuffer[offset] = zInv;
        return true;
      }
      
      return false;
    }
 
    function checkForCulling(transformed, indices) {
      var p0 = transformed[indices[0]];
      var p1 = transformed[indices[1]];
      var p2 = transformed[indices[2]];
      // Triangle normal
      var normal = getTriangleNormal(p0,p1,p2);
      // Triangle center
      var center = getCentroid(p0,p1,p2);
      // Direction vector from triangle to origin
      var vto = multiply(-1,center);
      return dotProduct(vto,normal) < 0;
    }
    //----------------------------------------------------------  --------------//
    //                         Lighting and shadows                           //
    //------------------------------------------------------------------------//

    function computeLighting(vertex, normal,  scene, reflectivity) {
      if (reflectivity == -1) {
        return new Vertex(1,1,1);
      }
      //var totalLight = 0;
      var totalLight = new Vertex(0,0,0);

      for (let i = 0 ; i<scene.lights.length; i++) {
        
        light = scene.lights[i];
        let lightColor = light.color;
        
        if (light.type == lightType.AMBIENT) {
          let ambient = light.intensity;
          totalLight = add(totalLight, multiply(ambient, lightColor));
        } else {
          var vl;
          if (light.type == lightType.POINT) {
            vl = subtract(light.mat, vertex);
          } else if (light.type == lightType.DIRECTIONAL){
            vl = light.vl;
          }
          // Diffuse light
          let nDotL = dotProduct(normal, vl);
          var diffuse = 0;
          if (nDotL>0.2) { 
            if (light.type == lightType.POINT) {
              diffuse= 1/vectorLength(vl) * (light.intensity * nDotL / (vectorLength(normal) * vectorLength(vl)));
            } else {
              diffuse = light.intensity * nDotL / (vectorLength(normal) * vectorLength(vl));
            }
          }
          //Specular light
          var specular = 0;
          if (reflectivity != 0) {
            let vecR = subtract(multiply(2.0*dotProduct(normal, vl), normal), vl);
            let view = subtract(camera.position, vertex);
            let rDotV = dotProduct(vecR, view);
            if (rDotV > 0) {
              specular = light.intensity * Math.pow(rDotV / (vectorLength(vecR) * vectorLength(view)), reflectivity); 
            }
          }
          totalLight = add(totalLight, multiply(specular+diffuse, lightColor));
          
        }
      }
      return totalLight;
    }
    //------------------------------------------------------------------------//
    //                              Rendering                                 //
    //------------------------------------------------------------------------//

    function drawLine(p0, p1, color) {
        // Check if line is more horizontal than vertical
        if (Math.abs(p1.x-p0.x) > Math.abs(p1.y-p0.y)) {
          if (p0.x > p1.x) {
            var p =  p0;
            p0 = p1;
            p1 = p;
          }
          var yArray = interpolate(p0.x, p0.y, p1.x, p1.y);
          for (let i = p0.x; i < p1.x; i++) {
            putPixel(i, yArray[i-p0.x],color);
          }
        } else {
          if (p0.y > p1.y) {
            var p =  p0;
            p0 = p1;
            p1 = p;
          }
          var xArray = interpolate(p0.y, p0.x, p1.y, p1.x);
          for (let i = p0.y; i < p1.y; i++) {
            putPixel(xArray[i-p0.y], i, color);
          }
        }
    }
    function drawWireframeTriangle(p0,p1,p2, color) {
      drawLine(p0, p1, color);
      drawLine(p1, p2, color);
      drawLine(p2, p0, color);
    }
    function viewportToCanvas(x,y, canvas) {
      return new Vertex(parseInt(x*canvas.width/viewportWidth), parseInt(y*canvas.height/viewportHeight));
    }
    function canvasToViewport(x,y, canvas) {
      return new Vertex(x*viewportWidth/canvas.width, y*viewportHeight/canvas.height);
    }
    function projectVertex(v, canvas) {
      return viewportToCanvas(v.x*zProjectionPlane/v.z,v.y*zProjectionPlane/v.z, canvas);
    }
    function unProjectVertex(x,y,z,canvas) {
      x = x*z / zProjectionPlane;
      y = y*z / zProjectionPlane;
      var p = canvasToViewport(x,y, canvas);
      return new Vertex(p.x, p.y, z);
    }
    function renderTriangle(triangle, transformed, projected, instance, scene, canvas, rotationMat) {
    
      // Sorted indices
      var [i0,i1,i2] = sortIndices(triangle.indices, projected);
      // Transformed vertices
      var t0 = transformed[triangle.indices[i0]];
      var t1 = transformed[triangle.indices[i1]];
      var t2 = transformed[triangle.indices[i2]];
      // Projected vertices
      var p0 = projected[triangle.indices[i0]];
      var p1 = projected[triangle.indices[i1]];
      var p2 = projected[triangle.indices[i2]];
      // Vertex normals 
      var transform = multiplyMM(transpose(makeRotationMatrix(scene.camera.orientation)), rotationMat);
    
      
      var n0 = arrayToVertex(multiplyMV(transform, triangle.normals[i0]));
      var n1 = arrayToVertex(multiplyMV(transform, triangle.normals[i1]));
      var n2 = arrayToVertex(multiplyMV(transform, triangle.normals[i2]));
      //Interpolated normal vectors for Phong shading
      var [nx02, nx012] = interpolateEdges(p0.y, n0.x, p1.y, n1.x, p2.y, n2.x);
      var [ny02, ny012] = interpolateEdges(p0.y, n0.y, p1.y, n1.y, p2.y, n2.y);
      var [nz02, nz012] = interpolateEdges(p0.y, n0.z, p1.y, n1.z, p2.y, n2.z);
      // Vertexs of the triangle edges
      var [x02, x012]   = interpolateEdges(p0.y,p0.x,p1.y,p1.x,p2.y,p2.x);
      var [iz02, iz012] = interpolateEdges(p0.y, 1.0/t0.z, p1.y, 1.0/t1.z, p2.y, 1.0/t2.z);
      // UV coordinates for textures
      var hasTexture = typeof triangle.texture === 'undefined' ? false : true; 
      if (hasTexture ) {
        var [uz02, uz012] = interpolateEdges(p0.y, triangle.UVs[i0].x / t0.z,p1.y, triangle.UVs[i1].x / t1.z,p2.y, triangle.UVs[i2].x / t2.z);
        var [vz02, vz012] = interpolateEdges(p0.y, triangle.UVs[i0].y / t0.z,p1.y, triangle.UVs[i1].y / t1.z,p2.y, triangle.UVs[i2].y / t2.z);
      }
      // Determine left and right sides
      var m = parseInt(x012.length/2);
      if (x02[m] < x012[m]) {
        var [xLeft, xRight] = [x02, x012];
        var [izLeft, izRight] = [iz02, iz012];
        var [nxLeft, nxRight] = [nx02, nx012];
        var [nyLeft, nyRight] = [ny02, ny012];
        var [nzLeft, nzRight] = [nz02, nz012];
        if (hasTexture) {
          var [uzLeft, uzRight] = [uz02, uz012];
          var [vzLeft, vzRight] = [vz02, vz012];
        }
      } else {
        var [xLeft, xRight] = [x012, x02];
        var [izLeft, izRight] = [iz012, iz02];
        var [nxLeft, nxRight] = [nx012, nx02];
        var [nyLeft, nyRight] = [ny012, ny02];
        var [nzLeft, nzRight] = [nz012, nz02];
        if (hasTexture) {
          var [uzLeft, uzRight] = [uz012, uz02];
          var [vzLeft, vzRight] = [vz012, vz02];
        }
      }

      // Draw the segments
      for (let y = p0.y, l1=p2.y; y <= l1; y++) {
        let y0 = p0.y;
        let xL = parseInt(xLeft[y-y0]);
        let xR = parseInt(xRight[y-y0]);
        let izSegment = interpolate(xL, izLeft[y - y0], xR, izRight[y - y0]);
        let nxSegment = interpolate(xL, nxLeft[y - y0], xR, nxRight[y - y0]);
        let nySegment = interpolate(xL, nyLeft[y - y0], xR, nyRight[y - y0]);
        let nzSegment = interpolate(xL, nzLeft[y - y0], xR, nzRight[y - y0]);
        let uzSegment, vzSegment;
        if (hasTexture) {
          uzSegment = interpolate(xL, uzLeft[y - y0], xR, uzRight[y - y0]);
          vzSegment = interpolate(xL, vzLeft[y - y0], xR, vzRight[y - y0]);
        }  
        for (let x = xL, l2 = xR; x <= l2; x++) {
          let iz = izSegment[x - xL];
          if (updateDepthBuffer(x, y, iz, canvas)) {  
            let vertex = unProjectVertex(x, y, 1.0/iz, canvas);
            let normal = new Vertex(nxSegment[x - xL], nySegment[x - xL], nzSegment[x - xL]);
            let totalLight = computeLighting(vertex, normal, scene, instance.reflectivity);
            let color;
            if (hasTexture) {
              color = triangle.texture.getTexel(uzSegment[x - xL] / iz, vzSegment[x - xL] / iz);
            } else {
              color = triangle.color;
            }
            color = addColors(color, instance.colorShift);
            let shadedColor = multiplyColors(totalLight, color);
            putPixel(x,y,shadedColor.toRGBA(), canvas);
          }
        }
      }
    }
    function renderInstance(instance, scene, canvas, parentMatrices) {
      var model = instance.model;
      var camera  = scene.camera;
      // Get the model matrix
      var translationMat = makeTranslationMatrix(instance.position);
      var rotationMat = makeRotationMatrix(instance.rotation);
      var scaleMat = makeScaleMatrix(instance.scaling);
      var modelMatrix, rotation;
      if (parentMatrices) {
        var parentMatrix = multiplyMM(parentMatrices[0], multiplyMM(parentMatrices[1],parentMatrices[2]));
        modelMatrix =  multiplyMM(translationMat, multiplyMM(rotationMat,scaleMat));
        modelMatrix = multiplyMM(parentMatrix, modelMatrix);
        rotation = multiplyMM(parentMatrices[1],rotationMat);
      } else {
        modelMatrix =  multiplyMM(translationMat,multiplyMM(rotationMat,scaleMat));
        rotation = rotationMat;
      }
      
      var transformedVertices = [];
      // Get the vertices in world space
      for (let i = 0; i<model.vertices.length; i++) {
        transformedVertices[i] = arrayToVertex(multiplyMV(modelMatrix, model.vertices[i]));
      }
      // Check the model for clipping
      var boundingSphere = instance.getBoundingSphere(transformedVertices);
      if (checkForClipping(boundingSphere, camera)) {
        return null;
      }
      // Get the view matrix
      var viewMatrix = makeCameraMatrix(camera);
      // Getting the vertices in view space
      for (let i = 0; i<model.vertices.length; i++) {
        transformedVertices[i] = arrayToVertex(multiplyMV(viewMatrix, transformedVertices[i]));
      }

      var transformedModel = new Model(model.name, transformedVertices, model.triangles);
 
      // Check the individual model triangles for clipping
      for (let plane of camera.clippingPlanes) {
        transformedModel = clipModel(transformedModel, plane);
      }
      // Projecting the vertices in world space
      var projectedVertices = [];
      transformedVertices = transformedModel.vertices;
      for (let v of transformedVertices) {
        projectedVertices.push(projectVertex(v, canvas));
      }
      
      // Rendering the triangles
      for (let t of transformedModel.triangles) {
        if (!checkForCulling(transformedVertices, t.indices)) {
          renderTriangle(t, transformedVertices,projectedVertices, instance, scene, canvas,rotation);
        }
      }
      // Rendering any children instances
      if (instance.children) {
        for (let childrenInstance of instance.children) {
          renderInstance(childrenInstance,scene,canvas, [translationMat,rotationMat,scaleMat]);
        }
      }
    }
    function renderScene(scene, canvas) {
      for (var light of scene.lights) {
        if (light.type == lightType.DIRECTIONAL) {
          let mat =  makeRotationMatrix(scene.camera.orientation);
          light.vl = arrayToVertex(multiplyMV(mat, light.direction));
        } else if(light.type == lightType.POINT) {
          let cameraMat = makeCameraMatrix(camera);
          light.mat= arrayToVertex(multiplyMV(cameraMat, light.position));
        }
      }
      var instances = scene.instances;
      
      for (let i=0; i<instances.length; i++) {
        if (Array.isArray(instances[i])) {
          for (let j=0; j<instances[i].length; j++) {
            if (instances[i][j]!= null){
              renderInstance(instances[i][j], scene, canvas);
            }
          }
        } else {
          renderInstance(instances[i], scene, canvas);
        }
      }
    }
    //------------------------------------------------------------------------//
    //                            Event Handling                              //
    //------------------------------------------------------------------------//
    var playerTranslate = new Vertex(0,0,0);
    var playerRotate = new Vertex(0,0,0);
    var speed = 0.075;
    var shoot = false;

    // Laser projectile
    var laserSpeed = 0.3;
    var laserFrameCount = 0;

    function handleKeyPress(event) {
      if(event.keyCode == 37) {
        playerTranslate.x = -speed;
        playerRotate.y =  100 *speed;
      }
      else if(event.keyCode == 39) {
        playerTranslate.x = speed;
        playerRotate.y = - 100 * speed;
      }
      if (event.keyCode == 32) {
        shoot=true;
      }
    }
    function handleKeyRelease(event) {
      if(event.keyCode == 37) {
        playerTranslate.x = 0;
        playerRotate.y = 0;
      }
      else if(event.keyCode == 39) {
        playerTranslate.x = 0;
        playerRotate.y = 0;
      }
      if (event.keyCode == 32) {
        shoot= false;
        laserFrameCount = 0;
      }
    }

    document.addEventListener('keydown', handleKeyPress, true);
    document.addEventListener('keyup', handleKeyRelease, true);
    //------------------------------------------------------------------------//
    //                               Animations                               //
    //------------------------------------------------------------------------//
    // Limiting frame rate to 60 fps
    var stop = false;
    var frameCount = 0;
    var fps =  30;
    var fpsInterval, startTime, now, then, elapsed;

    fpsInterval = 1000 / fps;
    then = Date.now();
    startTime = then;

    // Frame count since the start of the game
    var frameCount = 0;
    // Array containing the sequence of enemies in the level. 0 = nothing, 1 = cube
    var enemiesSequence = [
      [1,0,1],
      [0,1,0],
      [1,0,1],
      [0,1,0],
      [1,0,1],
    ];
    var sequenceIndex = 0;

    function animateEnemies(entityArray, frames) {
      let enemies = entityArray;

      if ( frames % 30 == 0 && enemiesSequence.length != sequenceIndex) {
        let row = enemiesSequence[sequenceIndex++];
        let newInstance;
        let newLight;
        for (let i=0; i<row.length; i++) {
          switch (row[i]) {
            case 0:
              continue;
            case 1:
              newInstance = new Instance(Object.assign({},whiteCube), new Vertex(i-1, 0.5, 20),new Vertex(0, 180, 0), new Vertex(0.5, 0.2, 0.2), 1000);
              break;
          };
          enemies.push(new GameEntity("Cube", newInstance, null, 3));
        }
        
      }

     
      for (let i=0; i<enemies.length; i++) {
        if (enemies[i]!= null) {
          if  (enemies[i].instance.position.z < 1) {
            enemies.splice(i,1);
          } else {
            enemies[i].instance.translate(new Vertex(0,0,-0.15));
          }
        }
      }
      return enemies;
    }
    function animateProjectiles(entityArray, pos) {
      let projectiles = entityArray;
      if (shoot) {
          if (laserFrameCount++ % 4 == 0) {
            let projInstance = new Instance(greenCube, new Vertex(pos, 0.5, 3), new Vertex(0, 180, 0), new Vertex(0.02, 0.02, 0.2), -1);
            let projLight =  new Light(lightType.POINT, 0.1, projInstance.position, null, vertexFromRGBA(colors.GREEN));
            projectiles.push(new GameEntity("Laser", projInstance, projLight, 0));
          }
        }
      for (let i=0; i<projectiles.length; i++) {
        if (projectiles[i]!= null) {
          if  (projectiles[i].instance.position.z > 20) {
            projectiles.splice(i,1);
          } else {
            projectiles[i].instance.translate(new Vertex(0,0,0.30));
            projectiles[i].light.translate(new Vertex(0,0,0.30));
          }
        }
      }
      return projectiles;
    }
    //------------------------------------------------------------------------//
    //                               Gameplay                                 //
    //------------------------------------------------------------------------//

    // Detect collision between an object and all the objects in an array
    function checkForCollision(entity, entityArray) {
      var sphere = entity.instance.boundingSphere;

      for (let i=0; i<entityArray.length; i++) {
        let d = distance(sphere.position, entityArray[i].instance.position);
        if (d<sphere.radius) {
          return i;
        }
      }
      return null;
    }
    // Detect and handle damages between all enemies and the player projectiles
    function checkEnemiesDamage(enemies, projectiles) {
      for (let i = 0; i<enemies.length; i++) {
        let projIndex = checkForCollision(enemies[i], projectiles);
        if (projIndex!= null) {
          enemies[i].hp -= 1;
          projectiles.splice(projIndex,1);
          if (enemies[i].hp <=0) {
            enemies.splice(i,1);
          } else {
            enemies[i].instance.colorShift = new Vertex(0.5 * 1/enemies[i].hp,0,0);
          }
        }
     
      }
      return [enemies, projectiles];
    }
    //------------------------------------------------------------------------//
    //                                 Main                                   //
    //------------------------------------------------------------------------//
    function createCubeModel(color, texture) {
      color = vertexFromRGBA(color);
      var vertices = [
        new Vertex(1,1,1),   // 0
        new Vertex(-1,1,1),  // 1
        new Vertex(-1,-1,1), // 2
        new Vertex(1,-1,1),  // 3
        new Vertex(1,1,-1),  // 4
        new Vertex(-1,1,-1), // 5
        new Vertex(-1,-1,-1),// 6
        new Vertex(1,-1,-1)  // 7
      ];
      var normals = [
        [new Vertex(0, 0, 1), new Vertex(0, 0, 1), new Vertex(0, 0, 1)],
        [new Vertex(0, 0, 1), new Vertex(0, 0, 1), new Vertex(0, 0, 1)],
        [new Vertex(1, 0, 0), new Vertex(1, 0, 0), new Vertex(1, 0, 0)],
        [new Vertex(1, 0, 0), new Vertex(1, 0, 0), new Vertex(1, 0, 0)],
        [new Vertex(0, 0, -1), new Vertex(0, 0, -1), new Vertex(0, 0, -1)],
        [new Vertex(0, 0, -1), new Vertex(0, 0, -1), new Vertex(0, 0, -1)],
        [new Vertex(-1, 0, 0), new Vertex(-1, 0, 0), new Vertex(-1, 0, 0)],
        [new Vertex(-1, 0, 0), new Vertex(-1, 0, 0), new Vertex(-1, 0, 0)],
        [new Vertex(0, 1, 0), new Vertex(0, 1, 0), new Vertex(0, 1, 0)],
        [new Vertex(0, 1, 0), new Vertex(0, 1, 0), new Vertex(0, 1, 0)],
        [new Vertex(0, -1, 0), new Vertex(0, -1, 0), new Vertex(0, -1, 0)],
        [new Vertex(0, -1, 0), new Vertex(0, -1, 0), new Vertex(0, -1, 0)],
      ];
      var UVs = [
        [new Vertex(0, 0), new Vertex(1, 0), new Vertex(1, 1)],
        [new Vertex(0, 0), new Vertex(1, 1), new Vertex(0, 1)],
        [new Vertex(0, 0), new Vertex(1, 0), new Vertex(1, 1)],
        [new Vertex(0, 0), new Vertex(1, 1), new Vertex(0, 1)],
        [new Vertex(0, 0), new Vertex(1, 0), new Vertex(1, 1)],
        [new Vertex(0, 0), new Vertex(1, 1), new Vertex(0, 1)],
        [new Vertex(0, 0), new Vertex(1, 0), new Vertex(1, 1)],
        [new Vertex(0, 0), new Vertex(1, 1), new Vertex(0, 1)],
        [new Vertex(0, 0), new Vertex(1, 0), new Vertex(1, 1)],
        [new Vertex(0, 0), new Vertex(1, 1), new Vertex(0, 1)], 
        [new Vertex(0, 0), new Vertex(1, 0), new Vertex(1, 1)], 
        [new Vertex(0, 0), new Vertex(1, 1), new Vertex(0, 1)]
      ];
      var triangles = [
        new Triangle([0,1,2], normals[0], UVs[0], color, texture),
        new Triangle([0,2,3], normals[1], UVs[1], color, texture),
        new Triangle([4,0,3], normals[2], UVs[2], color, texture),
        new Triangle([4,3,7], normals[3], UVs[3], color, texture),
        new Triangle([5,4,7], normals[4], UVs[4], color, texture),
        new Triangle([5,7,6], normals[5], UVs[5], color, texture),
        new Triangle([1,5,6], normals[6], UVs[6], color, texture),
        new Triangle([1,6,2], normals[7], UVs[7], color, texture),
        new Triangle([4,5,1], normals[8], UVs[8], color, texture),
        new Triangle([4,1,0], normals[9], UVs[9], color, texture),
        new Triangle([2,6,7], normals[10], UVs[10], color, texture),
        new Triangle([2,7,3], normals[11], UVs[11], color, texture)
      ];
      return new Model("Cube", vertices, triangles);
    }

    function createPlaneModel(color, texture) {
      color = vertexFromRGBA(color);
      var vertices = [
        new Vertex(1,0,1),   // 0
        new Vertex(-1,0,1),  // 1
        new Vertex(1,0,-1), // 2
        new Vertex(-1,0,-1),  // 3
      ]
      var normals = [
        [new Vertex(0, 1, 0), new Vertex(0, 1, 0), new Vertex(0, 1, 0)],
        [new Vertex(0, 1, 0), new Vertex(0, 1, 0), new Vertex(0, 1, 0)],
      ];
      var UVs = [
        [new Vertex(0, 1), new Vertex(1, 1), new Vertex(1, 0)],
        [new Vertex(0, 1), new Vertex(1, 0), new Vertex(0, 0)],
      ]
      var triangles = [
        new Triangle([2,3,1], normals[0], UVs[0], color, texture),
        new Triangle([2,1,0], normals[1], UVs[1], color, texture)
      ]
      return new Model("Plane", vertices, triangles);
    }
    
    function createPolyPlaneModel(sides, color, texture) {
      color = vertexFromRGBA(color);
      var angle = 360/sides;
      var vertices = [
        new Vertex(0,0,0), 
        new Vertex(Math.cos(toRad(0)), 0, Math.sin(toRad(0)))
      ];
      var triangles = [];
      var normals = [new Vertex(0, 1, 0), new Vertex(0, 1, 0), new Vertex(0, 1, 0)];
      for (var i=1; i<sides;i++) {
        vertices.push(new Vertex(Math.cos(toRad(angle*i)), 0, Math.sin(toRad(angle*i))));
        let UVs = [toUV(vertices[0]), toUV(vertices[i+1]), toUV(vertices[i]) ];
        triangles.push(new Triangle([0, i+1, i], normals, UVs, color, texture));
        
      }
      let UVs = [toUV(vertices[0]), toUV(vertices[1]), toUV(vertices[vertices.length-1])];
  
      triangles.push(new Triangle([0, 1, vertices.length-1], normals, UVs, color, texture));
     
      return new Model("PolyPlane", vertices, triangles);
    }
    // #TODO Compute UVs for textures
    function createPyramidModel(sides, color) {
      color = vertexFromRGBA(color);
      var angle = 360/sides;
      var vertices = [
        new Vertex(0,0,0), // Center point of base
        new Vertex(0,1,0), // Apex
        new Vertex(Math.cos(toRad(0)), 0, Math.sin(toRad(0)))
      ];

      var triangles = [];
      var baseNormals = [new Vertex(0, -1, 0), new Vertex(0, -1, 0), new Vertex(0, -1, 0)];
      
      let UVs = [new Vertex(0, 0, 0), new Vertex(0, 0, 0), new Vertex(0, 0, 0)];
      for (var i=2; i<=sides;i++) {
        vertices.push(new Vertex(Math.cos(toRad(angle*(i-1))), 0, Math.sin(toRad(angle*(i-1)))));
        triangles.push(new Triangle([0, i, i+1], baseNormals, UVs, color));
        let normalAngle = toRad((angle*(i-1) - angle*(i-2))/2 + angle*(i-2));
        let sideNormal = new Vertex(Math.cos(normalAngle), 1, Math.sin(normalAngle));
        triangles.push(new Triangle([i, 1 , i+1], [sideNormal, sideNormal, sideNormal], UVs, color));
      }
      var normalAngle = toRad(360 - angle/2);
      var sideNormal = new Vertex(Math.cos(normalAngle), 1, Math.sin(normalAngle));
      triangles.push(new Triangle([0, vertices.length-1, 2], baseNormals, UVs, color));
      triangles.push(new Triangle([vertices.length-1, 1, 2], [sideNormal, sideNormal, sideNormal], UVs, color));

      return new Model("Pyramid", vertices, triangles);
    }
    function createPrismModel(sides, color) {
      color = vertexFromRGBA(color);
      var angle = 360/sides;
      var vertices = [
        new Vertex(0,0,0), // Center point of bottom base
        new Vertex(0,1,0), // Center point of top base
        new Vertex(Math.cos(toRad(0)), 0, Math.sin(toRad(0))),
        new Vertex(Math.cos(toRad(0)), 1, Math.sin(toRad(0)))
      ];

      var triangles = [];
      var bottomBaseNormals = [new Vertex(0, -1, 0), new Vertex(0, -1, 0), new Vertex(0, -1, 0)];
      var topBaseNormals = [new Vertex(0, 1, 0), new Vertex(0, 1, 0), new Vertex(0, 1, 0)];
      let UVs = [new Vertex(0, 0, 0), new Vertex(0, 0, 0), new Vertex(0, 0, 0)];

      for (var i=2; i<sides*2; i+=2) {
        vertices.push(new Vertex(Math.cos(toRad(angle*(i/2))), 0, Math.sin(toRad(angle*(i/2))))); // i+2
        vertices.push(new Vertex(Math.cos(toRad(angle*(i/2))), 1, Math.sin(toRad(angle*(i/2))))); // i+3
        triangles.push(new Triangle([0, i, i+2], bottomBaseNormals, UVs, color));
        triangles.push(new Triangle([1, i+3, i+1], topBaseNormals, UVs, color));
        let normalAngle = toRad((angle*(i/2) - angle*(i/2-1))/2 + angle*(i/2-1));
        let sideNormal = new Vertex(Math.cos(normalAngle), 0, Math.sin(normalAngle));
        triangles.push(new Triangle([i+1, i+2 , i], [sideNormal, sideNormal, sideNormal], UVs, color));
        triangles.push(new Triangle([i+1, i+3 , i+2], [sideNormal, sideNormal, sideNormal], UVs, color));
      }
      var normalAngle = toRad(360 - angle/2);
      var sideNormal = new Vertex(Math.cos(normalAngle), 0, Math.sin(normalAngle));
      triangles.push(new Triangle([0, vertices.length-2, 2], bottomBaseNormals, UVs, color));
      triangles.push(new Triangle([1, 3, vertices.length-1], topBaseNormals, UVs, color));
      triangles.push(new Triangle([vertices.length-2, vertices.length-1, 2], [sideNormal, sideNormal, sideNormal], UVs, color));
      triangles.push(new Triangle([ vertices.length-1, 3, 2], [sideNormal, sideNormal, sideNormal], UVs, color));

      return new Model("Prism", vertices, triangles);
    }
    // #TODO Compute UVs for textures
    function createSphereModel(divs, color) {
      color = vertexFromRGBA(color);
      var vertices = [];
      var triangles = [];

      var delta_angle = 2.0*Math.PI / divs;

      // Generate vertices and normals.
      for (var d = 0; d < divs + 2; d++) {
        var y = (2.0 / divs) * (d - divs/2);
        var radius = Math.sqrt(1.0 - y*y);
        for (var i = 0; i < divs; i++) {
          var vertex = new Vertex(radius*Math.cos(i*delta_angle), y, radius*Math.sin(i*delta_angle));
          vertices.push(vertex);
        }
      }

      // Generate triangles.
      for (var d = 0; d < divs; d++) {
        for (var i = 0; i < divs; i++) {
          var i0 = d*divs + i;
          // Indices, normals, UVs, color, texture
          // Indices, color, normals
          let indices = [i0, i0+divs+1, i0+1];
          let normals = [vertices[i0], vertices[i0+divs+1], vertices[i0+1]];
          let UVs = [new Vertex(0,0,0), new Vertex(0,0,0), new Vertex(0,0,0)];
          triangles.push(new Triangle(indices,normals, UVs, color));
          indices = [i0, i0+divs, i0+divs+1];
          normals = [vertices[i0], vertices[i0+divs], vertices[i0+divs+1]];
          triangles.push(new Triangle(indices, normals, UVs, color));
        }
      }
      return new Model("Sphere", vertices, triangles);
    }

    var portalTexture = new Texture("portal-texture.jpg");
    var spaceTexture = new Texture("space-texture-2.jpg");
    
    var greyCube = createCubeModel(colors.GREY);
    var whiteCube = createCubeModel(colors.WHITE);
    var greenCube = createCubeModel(colors.GREEN);
    var whitePlane = createCubeModel(colors.WHITE, spaceTexture);
    var purplePolyPlane = createPolyPlaneModel(16, colors.PURPLE, );
    var greyPlane = createPlaneModel(colors.GREY);
    var blackSphere = createSphereModel(15, colors.WHITE);
    var orangeSphere = createSphereModel(15, colors.ORANGE);
    var greyPolyPlane = createPolyPlaneModel(16, colors.WHITE, portalTexture);
    var lightGrey6Pyramid = createPyramidModel(6, colors.LIGHTGREY);
    var whitePrism = createPrismModel(6, colors.WHITE);
    var greyPrism = createPrismModel(8, colors.GREY);
    var indigoPrism = createPrismModel(3, colors.INDIGO);
    var dynamicForegroundInstances = [
    ];
    var dynamicBackgroundInstances = [
      new Instance(greyPolyPlane, new Vertex(0, 1.5, 18),new Vertex(-90, 0, 0), new Vertex(3, 0, 3), -1),
    ];
    var staticForegroundInstances = [
      //new Instance(greyPlane, new Vertex(0, 0.2, 7.5),new Vertex(0, 0, 0), new Vertex(1.75, 0, 10), 0),
      //new Instance(whiteCube, new Vertex(1.75, 0.2, 2),new Vertex(0, 180, 0), new Vertex(0.1, 0.1, 5), -1),
      //new Instance(whiteCube, new Vertex(-1.75, 0.2, 2),new Vertex(0, 180, 0), new Vertex(0.1, 0.1, 5), -1),
    ];
    var staticBackgroundInstances = [
      new Instance(whitePlane, new Vertex(0, -2, 15),new Vertex(-90, 0, 0), new Vertex(10, 0, 10), 0),
    ];
    // #TODO Compute the planes normals for any fovs.
    var clippingPlanes = [
      new Plane(new Vertex(0, 0, 1), -zProjectionPlane), // Near
      new Plane(new Vertex(Math.sqrt(2) , 0, Math.sqrt(2)), 0), // Left
      new Plane(new Vertex(-Math.sqrt(2), 0, Math.sqrt(2)), 0), // Right
      new Plane(new Vertex(0, -Math.sqrt(2), Math.sqrt(2)), 0), // Top
      new Plane(new Vertex(0, Math.sqrt(2),Math.sqrt(2)), 0),
    ];
    // Position, rotation, clipping planes
    var camera = new Camera(new Vertex(0, 2, 0), new Vertex(15, 0, 0), clippingPlanes);
    // type, totalLight, position, direction
    var lights = [
      new Light(lightType.AMBIENT, 0.6),
      new Light(lightType.POINT, 10, new Vertex(0, 3, 18)),


      //new Light(lightType.DIRECTIONAL, 0.8, null, new Vertex(4,2,-3)),
      
    ];
    var foregroundStatic = new Scene(staticForegroundInstances , camera, lights);
    var backgroundStatic = new Scene(staticBackgroundInstances , camera, lights);

    var enemies = [];
    var projectiles = [];
    var leftFlame = new Instance(orangeSphere, new Vertex(-0.4, -0.05, -0.1),new Vertex(0, 0, 0), new Vertex(0.15,0.05,0.3), -1);
    var rightFlame = new Instance(orangeSphere, new Vertex(0.4, -0.05, -0.1),new Vertex(0, 0, 0), new Vertex(0.15,0.05,0.3), -1);
    var rightReactor = new Instance(greyPrism, new Vertex(0.4, -0.05, -0.1),new Vertex(0, 0, 0), new Vertex(0.25,0.05,0.5), 1000);
    var leftReactor = new Instance(greyPrism, new Vertex(-0.4, -0.05, -0.1),new Vertex(0, 0, 0), new Vertex(0.25,0.05,0.5), 1000);
    var leftWing = new Instance(indigoPrism, new Vertex(-0.9, 0.17, 0),new Vertex(90, 192, 15), new Vertex(1,0.6,0.3), 1000);
    var rightWing = new Instance(indigoPrism, new Vertex(0.9, 0.17, 0),new Vertex(90, -14, 15), new Vertex(1,0.6,0.3), 1000);
    var cockpit = new Instance(blackSphere, new Vertex(0, 0.2, -1),new Vertex(-90, 0, 0), new Vertex(0.3,0.75,0.1), 1000);
    var bodyParts = [cockpit, rightWing, leftWing,  rightReactor, leftReactor, leftFlame, rightFlame];
    var body = new Instance(lightGrey6Pyramid, new Vertex(0, 0.5, 2.5),new Vertex(90,0, 0), new Vertex(0.25, 1, 0.1), 1000, bodyParts);
    var playerInstance = body;
    //var playerLight = new Light(lightType.POINT, 3,new Vertex(0, 2, -2));
    var playerLight = null;
    var player = new GameEntity("Player", playerInstance, playerLight, 5);
    
    function gameLoop() {
      requestAnimationFrame(gameLoop);
      now = Date.now();
      elapsed = now - then;
      if (elapsed > fpsInterval) {
        frameCount++;
        then = now - (elapsed % fpsInterval);
        clearBuffers(mainCanvas);
        let playerPosX = player.instance.position.x + playerTranslate.x;
        let playerAngleY = player.instance.rotation.y + playerRotate.y;
        if (playerPosX > -1.45 && playerPosX < 1.45) {
          player.instance.translate(playerTranslate);
          //player.light.translate(playerTranslate);
        }
        if (playerAngleY >= -20 && playerAngleY <= 20 && playerRotate.y != 0){
          player.instance.rotate(playerRotate);
        } else {
          if (playerAngleY < 0 && playerRotate.y == 0) {
            player.instance.rotate(new Vertex(0,20*speed,0));
          } else if (playerAngleY > 0 && playerRotate.y == 0) {
            player.instance.rotate(new Vertex(0,-20*speed,0));
          }
        }
        enemies = animateEnemies(enemies, frameCount);
        projectiles  = animateProjectiles(projectiles, playerPosX);
        [enemies, projectiles] = checkEnemiesDamage(enemies,projectiles);

        let newLights = lights.slice();
        let newForegroundInstances = dynamicForegroundInstances.slice();
        let newBackgroundInstances = dynamicBackgroundInstances.slice();
        let entities = [];
        entities.push(player);
        entities.push(enemies);
        entities.push(projectiles);
        for (let i = 0; i< entities.length; i++) {
          if (Array.isArray(entities[i])) {
            for (let j=0; j<entities[i].length; j++) {
              if (entities[i][j].light != null) {
                newLights.push(entities[i][j].light);
              }
              newForegroundInstances.push(entities[i][j].instance);
            }
          } else {
            if (entities[i].light != null) {
              newLights.push(entities[i].light);
            }
            newForegroundInstances.push(entities[i].instance);
          }
        }
        // Setting up the scenes
        let foregroundDynamic = new Scene(newForegroundInstances, camera, newLights);
        let backgroundDynamic = new Scene(newBackgroundInstances, camera, newLights);

        // Drawing the scenes
        mainCanvas.context.drawImage(offScreenBackCanvas.element, 0, 0);  
        mainCanvas.buffer = mainCanvas.context.getImageData(0, 0, canvas.width, canvas.height);
        backgroundDynamic.instances[0].rotate(new Vertex(0,0.3,0));
        renderScene(backgroundDynamic,mainCanvas);
        updateCanvas(mainCanvas);
        mainCanvas.context.drawImage(offScreenFrontCanvas.element, 0, 0);  
        mainCanvas.buffer = mainCanvas.context.getImageData(0, 0, canvas.width, canvas.height);
        renderScene(foregroundDynamic,mainCanvas);
        updateCanvas(mainCanvas);
      }
    }
    
    function render() {
      renderScene(backgroundStatic,offScreenBackCanvas);
      updateCanvas(offScreenBackCanvas);
      renderScene(foregroundStatic,offScreenFrontCanvas);
      updateCanvas(offScreenFrontCanvas);
      gameLoop();
    }
    
    // Ugly hack - wait for texture to load.
    setTimeout(function() { render(); }, 50);
  </script>
</canvas>
</html>
