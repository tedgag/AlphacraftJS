<!DOCTYPE html>
<html>
<head>
<title>HTML Rasterizer</title>
</head>
<body>
<canvas id="canvas" width="600" height="600" style="border: 1px grey solid">
  <script>
  
    //------------------------------------------------------------------------//
    //                                 Enums                                  //
    //------------------------------------------------------------------------//
    const color = {
      RED : [255, 0, 0],
      GREEN : [0, 255, 0],
      BLUE : [0, 0, 255],
      YELLOW : [255, 255, 0],
      PURPLE : [255, 0, 255],
      CYAN : [0, 255, 255]
    }
    const lightType = {
      AMBIENT : "ambient",
      POINT : "point",
      DIRECTIONAL : "directional"
    }
    //------------------------------------------------------------------------//
    //                                Classes                                 //
    //------------------------------------------------------------------------//
    // 2D Point
    class Point {
      constructor(x,y,h) {
        this.x=x;
        this.y=y;
        this.h=h;
      }
    }
    // 3D Vertex
    class Vertex {
      constructor(x,y,z) {
        this.x=x;
        this.y=y;
        this.z=z;
      }
      toString() {
        return "<" + this.x + ", " + this.y + ", " + this.z + ">" ;
      }
    }
    // 3D Vertex with homogeneous coordinate
    class Vertex4 {
      constructor(x,y,z,w) {
        this.x=x;
        this.y=y;
        this.z=z;
        this.w=w;
      }
      toArray() {
        let a = [this.x,this.y,this.z,this.w];
        return a;
      }
    }
    // 4x4 matrix
    class Mat {
      constructor(values) {
        this.values = values;
      }
    }
    class Canvas {
      constructor(canvas) {
        this.element = canvas;
        this.context=canvas.getContext("2d");
        this.buffer= this.context.getImageData(0, 0, canvas.width, canvas.height);
        this.pitch = this.buffer.width * 4;
        this.width = canvas.width;
        this.height= canvas.height;
      }
    }
    class Triangle {
      constructor(indices,normals, color) {
        this.indices = indices;
        this.normals = normals;
        this.color = color;
      }
    }
    class Scene {
      constructor(instances, camera, lights) {
        this.instances = instances;
        this.camera = camera;
        this.lights =  lights;
      }
    }
    class Model {
      constructor(name,vertices,triangles) {
        this.name=name;
        this.vertices=vertices;
        this.triangles=triangles;
        
      }
    }
    class Instance {
      constructor(model,position,rotation,scaling, reflectivity) {
        this.model=model;
        this.position = position;
        this.rotation = rotation;
        this.scaling = scaling;
        this.reflectivity = reflectivity;
      }
      makeTransformMatrix() {
        let translationMat = makeTranslationMatrix(this.position);
        let rotationMat = makeRotationMatrix(this.rotation);
        let scaleMat = makeScaleMatrix(this.scaling);
        let mat = multiplyMM(rotationMat,scaleMat);
        return multiplyMM(translationMat,mat);
      }
    }
    class Camera {
      constructor(position, orientation, clippingPlanes) {
        this.position = position;
        this.orientation = orientation;
        this.clippingPlanes = clippingPlanes
      }
      translate (vector) {
        this.position.x += vector.x;
        this.position.y += vector.y;
        this.position.z += vector.z;
      }
    }
    class Plane {
      constructor(normal, distance) {
        this.normal = normal;
        // distance from origin to plane. Same thing as D in plane equation.
        this.distance = distance;
      }
    }
    class BoundingSphere {
      constructor(position,radius) {
        this.position = position;
        this.radius = radius;
      }
    }
    class Light {
      constructor(type, intensity, position, direction) {
        this.type = type;
        this.intensity = intensity;
        this.position = position;
        this.direction = direction;
      }
    }
    //------------------------------------------------------------------------//
    //                            Canvas Data                                 //
    //------------------------------------------------------------------------//
    // Main screen canvas
    var main = document.getElementById("canvas");
    var mainCanvas = new Canvas(main );

    // Offscreen canvas

    var offScreen = document.createElement('canvas');
    offScreen.width = main.width;
    offScreen.height = main.width;
    var offScreenCanvas = new Canvas(offScreen);

    //Viewport info
    var viewportWidth = 1;
    var viewportHeight = 1;

    // Distance between near plane and origin
    var zProjectionPlane = 1;
    // To store depth of pixels to be drawn
    var depthBuffer = new Array(canvas.width * canvas.height);

    function putPixel(x, y, color, canvas) {
      x = canvas.width/2 + Math.floor(x);
      y = canvas.height/2 - Math.floor(y) - 1;
      if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
        return;
      }
      var offset = 4*x + canvas.pitch*y;
      canvas.buffer.data[offset++] = color[0];
      canvas.buffer.data[offset++] = color[1];
      canvas.buffer.data[offset++] = color[2];
      canvas.buffer.data[offset++] = 255;
    }
    function updateCanvas(canvas) {
      canvas.context.putImageData(canvas.buffer, 0, 0);
    }
    function clearBuffers(canvas) {
      canvas.context.fillStyle = "#519693";
      canvas.context.fillRect(0, 0, canvas.width, canvas.height);
      canvas.buffer = canvas.context.getImageData(0, 0, canvas.width, canvas.height);
      depthBuffer = new Array(canvas.width * canvas.height);
    }
    //------------------------------------------------------------------------//
    //                     Linear algebra and helpers                         //
    //------------------------------------------------------------------------//
    // Add two vectors
    function addVectors(vec1, vec2) {
      return new Vertex(vec1.x + vec2.x, vec1.y + vec2.y, vec1.z + vec2.z);
    }
    // Subtract two vectors
    function subtractVectors(vec1, vec2) {
      vec2 = multiplyScalar(-1, vec2);
      return new Vertex(vec1.x + vec2.x, vec1.y + vec2.y, vec1.z + vec2.z);
    }
    // Multiply a vector by a scalar
    function multiplyScalar(s,vec) {
      return new Vertex(s*vec.x, s*vec.y, s*vec.z);
    }
    // Dot product between two vectors
    function dotProduct(vec1, vec2) {
      return vec1.x*vec2.x + vec1.y * vec2.y + vec1.z * vec2.z;
    }
    // Cross product between two vectors
    function crossProduct(vec1, vec2) {
      let i = vec1.y * vec2.z - vec1.z * vec2.y;
      let j = vec1.x * vec2.z - vec1.z * vec2.x;
      let k = vec1.x * vec2.y - vec1.y * vec2.x;
      return new Vertex(i, -j, k);
    }
    // Distance between two points.
    function distancePoints(p1,p2) {
      let d = Math.pow(p2.x-p1.x,2) + Math.pow(p2.y-p1.y,2)
      if (typeof p1.z != "undefined" && typeof p2.z != "undefined") {
        d += Math.pow(p2.z-p1.z,2)
      }
      return Math.sqrt(d);
    }
    
    // Mid point between two points.
    function midPoint(p1,p2) {
      let x = parseInt((p1.x+p2.x)/2);
      let y = parseInt((p1.y+p2.y)/2);
      if (typeof p1.z != "undefined" && typeof p2.z != "undefined") {
        let z = parseInt((p1.z+p2.z)/2);
        return new Vertex(x,y,z);
      } else {
        return new Point(x,y);
      }
    }

    // Return the transpose of the given matrix
    function transpose(mat) {
      let result = [];
      let values = mat.values;
      for (i=0;i<values.length;i++) {
        result[i]=[];
        for(j=0;j<values[0].length;j++) {
          result[i][j]=values[j][i];
        }
      }
      return new Mat(result);
    }
    // Multiply a matrix by a vector.
    function multiplyMV(mat,vec) {
      let v = vec.toArray();
      if (mat.values[0].length!=v.length) {
        return null;
      }

      let result=[];
      for (i=0;i<v.length;i++) {
        result.push(0);
      }
      let values = mat.values;

      for (i=0; i<values.length; i++) {
        for (j=0; j<values[i].length; j++) {
          result[i] += values[i][j] * v[j];
        }
      }
      return result;
    }
    // Multiply a matrix by another matrix
    function multiplyMM(mat1,mat2) {
      mat1Data = mat1.values;
      mat2Data = mat2.values;
      if (mat1Data[0].length!=mat2Data.length) {
        return null;
      }
      let result = [];
      for (i=0;i<mat1Data.length;i++) {
        result[i]=[];
        for(j=0;j<mat2Data[0].length;j++) {
          result[i][j]=0;
        }
      }
      for (i=0; i<mat1Data.length; i++) {
        for (j=0; j<mat2Data[i].length; j++){
          let dot=0;
          for (k=0; k<mat1Data[i].length; k++){
            dot+= mat1Data[i][k] * mat2Data[k][j];
          }
          result[i][j] = dot;
        }
      }
      return new Mat(result);
    }
    function arrayToVertex(array) {
      return new Vertex(array[0], array[1], array[2]);
    }
    function vertexToVertex4(vertex){
      return new Vertex4(vertex.x,vertex.y,vertex.z,1);
    }
    function interpolate(x0,y0,x1,y1) {
      if (x0==x1){
        return [ y0 ];
      }
      var values = [];
      var a = (y1-y0) / (x1-x0);
      var y = y0;
      for (i = x0; i <= x1; i++) {
        values.push(y);
        y=y+a;
      }
      return values;
    }
    function interpolateEdges(x0,y0,x1,y1,x2,y2) {
      var y01 = interpolate(x0,y0,x1,y1);
      var y12 = interpolate(x1,y1,x2,y2);
      var y02 = interpolate(x0,y0,x2,y2);
      

      y01.pop();
      var y012 = y01.concat(y12);
      return [y02, y012];
    }
    // Get the normal of a triangle
    function getTriangleNormal(v0,v1,v2){
      let v01 = subtractVectors(v1, v0);
      let v02 = subtractVectors(v2, v0);
      return crossProduct(v01,v02);
    }
    // Find the centroid of a triangle
    function getCentroid(v0,v1,v2) {
      return multiplyScalar(1/3, addVectors(addVectors(v0, v1), v2));
    }
    // Find the point where the line defined by a and b intersect the plane
    function planeIntersection(a,b, plane) {
      let bMinusA = subtractVectors(a, b);
      let num = - plane.distance - dotProduct(plane.normal, a);
      let denum = dotProduct(plane.normal, bMinusA);
      return addVectors(a, multiplyScalar(num/denum, bMinusA));
    }
    function sortIndices(indices, vertices) {
      var i0 = 0;
      var i1 = 1; 
      var i2 = 2;
      // p0.y <= p1.y <= p2.y
      if (vertices[indices[i1]].y < vertices[indices[i0]].y) { 
        var i = i0; 
        i0 = i1; 
        i1 = i; 
      }
      if (vertices[indices[i2]].y < vertices[indices[i0]].y) { 
        var i = i0; 
        i0 = i2; 
        i2 = i; 
      }
      if (vertices[indices[i2]].y < vertices[indices[i1]].y) { 
        var i = i1; 
        i1 = i2; 
        i2 = i; 
      }
      return [i0,i1,i2];
    }
    function vectorLength(vec) {
      return Math.sqrt(Math.pow(vec.x, 2) + Math.pow(vec.y,2) + Math.pow(vec.z, 2));
    }
    function clamp(value) {
      if (value < 0) { return 0; }
      if (value > 255) { return 255; }
      return value;
    }
    function multiplyColor(s, color) {
      return [clamp(s*color[0]), clamp(s*color[1]), clamp(s*color[2])];
    }
    //------------------------------------------------------------------------//
    //                        Transformation Matrices                         //
    //------------------------------------------------------------------------//

    // Translation matrix to the given position vector
    function makeTranslationMatrix(position) {
      let m = [
        [1,0,0,position.x],
        [0,1,0,position.y],
        [0,0,1,position.z],
        [0,0,0,1]
      ];
      return new Mat(m);
    }
    // Scale matrix for the given scaling vector
    function makeScaleMatrix(scaling) {
      let m = [
        [scaling.x,0,0,0],
        [0,scaling.y,0,0],
        [0,0,scaling.z,0],
        [0,0,0,1]
      ];
      return new Mat(m);
    }
    // Rotation matrix around x by the given angle (in degrees)
    function makeXRotationMatrix(angle) {
      let rad = angle*Math.PI/180;
      let m = [
        [1,0,0,0],
        [0,Math.cos(rad),-Math.sin(rad),0],
        [0,Math.sin(rad),Math.cos(rad),0],
        [0,0,0,1]
      ];
      return new Mat(m);
    }
    // Rotation matrix around y by the given angle (in degrees)
    function makeYRotationMatrix(angle) {
      let rad = angle*Math.PI/180;
      let m = [
        [Math.cos(rad),0,Math.sin(rad),0],
        [0,1,0,0],
        [-Math.sin(rad),0,Math.cos(rad),0],
        [0,0,0,1]
      ];
      return new Mat(m);
    }
    // Rotation matrix around z by the given angle (in degrees)
    function makeZRotationMatrix(angle) {
      let rad = angle*Math.PI/180;
      let m = [
        [Math.cos(rad),-Math.sin(rad),0,0],
        [Math.sin(rad),Math.cos(rad),0,0],
        [0,0,1,0],
        [0,0,0,1]
      ];
      return new Mat(m);
    }
    function makeRotationMatrix(orientation) {
      let yRotationMat = transpose(makeYRotationMatrix(orientation.y));
      let xRotationMat = transpose(makeXRotationMatrix(orientation.x));
      let zRotationMat = transpose(makeZRotationMatrix(orientation.z));
      return multiplyMM(xRotationMat, multiplyMM(yRotationMat, zRotationMat));
    }

    function makeCameraMatrix(camera){
      let rotationMat = makeRotationMatrix(camera.orientation);
      let translationMat = makeTranslationMatrix(multiplyScalar(-1,camera.position));
      return multiplyMM(rotationMat,translationMat);
    }
    
    //------------------------------------------------------------------------//
    //                               Clipping                                 //
    //------------------------------------------------------------------------//

    // Get the bounding sphere of an array of vertices based on Ritter's algorithm.
    function getBoundingSphere(vertices) {
      var x = vertices[0];
      var y = vertices[0];
      var d = 0;
      for (let v of vertices) {
        let d2 = distancePoints(x,v);
        if (d2 > d) {
          d = d2;
          y = v;
        }
      }
      let z = vertices[0];
      for (let v of vertices) {
        let d2 = distancePoints(y,v);
        if (d2 > d) {
          d = d2;
          z = v;
        }
      }
      let mid = midPoint(z,y);
      let radius = d/2;
      let expandRadius = false;
      for (let v of vertices) {
        let d2 = distancePoints(mid,v);
        if (d2>radius) {
          radius = d2;
        }
      }
      return new BoundingSphere(mid,radius);
    }
    // Checks if the bounding sphere is inside the view frustum defined by the camera.
    function checkForClipping(sphere, camera) {
      for (p of camera.clippingPlanes) {
        let d = dotProduct(p.normal, sphere.position) + p.distance;
        if (d < -sphere.radius) {
          return true;
        }
      }
      return false;
    }
    // Clip the individual triangles in the model.
    // #TODO Implement the recalculation of additional vertices attributes.
    function clipModel(model, plane) {
      var newTriangles = [];
      var newVertices = model.vertices;
      for (triangle of model.triangles) {
        let iIn = [];
        let iOut = [];
        let indices = triangle.indices;
        for (i = 0; i<indices.length; i++) {
          let v = newVertices[indices[i]];
          if (dotProduct(plane.normal, v) + plane.distance > 0) {
            iIn.push(i);
          } else {
            iOut.push(i);
          }
        }
        if (iIn.length == 0) {
          // Do nothing
        } else if (iIn.length == 3) {
          newTriangles.push(triangle);
        } else if (iIn.length == 1) {
          let newIndices = [];
          let q1 = planeIntersection(newVertices[indices[iIn[0]]],newVertices[indices[iOut[0]]], plane);
          let q2 = planeIntersection(newVertices[indices[iIn[0]]],newVertices[indices[iOut[1]]], plane);
          newIndices[iIn[0]] = newVertices.length;
          newVertices.push(q1);
          newIndices[iOut[0]] = newVertices.length;
          newVertices.push(q2);
          newIndices[iOut[1]] = indices[iIn[0]];
          newTriangles.push(new Triangle(newIndices, triangle.normals, triangle.color));
        } else if (iIn.length == 2) {
          
          let newIndices1 = [];
          let newIndices2 = [];
          let q1 = planeIntersection(newVertices[indices[iIn[0]]],newVertices[indices[iOut[0]]], plane);
          
          newIndices1[iOut[0]] = newVertices.length;
          newIndices2[iOut[0]] = newVertices.length;
          newVertices.push(q1);
          newIndices1[iIn[0]] = indices[iIn[0]];
          newIndices1[iIn[1]] = indices[iIn[1]];
          
          newTriangles.push(new Triangle(newIndices1,  triangle.normals, triangle.color));
          
          let q2 = planeIntersection(newVertices[indices[iIn[1]]],newVertices[indices[iOut[0]]], plane); 

          newIndices2[iIn[1]] = newVertices.length;
          newVertices.push(q2);
          newIndices2[iIn[0]] = indices[iIn[1]];
         
          newTriangles.push(new Triangle(newIndices2,  triangle.normals, triangle.color));
          
        }
      }
      
      return new Model(model.name, newVertices, newTriangles);
    }
    //------------------------------------------------------------------------//
    //                        Hidden surfaces removal                         //
    //------------------------------------------------------------------------//

    function updateDepthBuffer(x, y, zInv, canvas) {
      var x = canvas.width/2 + parseInt(x);
      var y = canvas.height/2 - parseInt(y) - 1;
     
      if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
        return false;
      }
      
      var offset = x + canvas.width*y;
      var data = depthBuffer[offset];
      if (data == undefined || data < zInv) {
        depthBuffer[offset] = zInv;
        return true;
      }
      
      return false;
    }
 
    function checkForCulling(transformed, indices) {
      var p0 = transformed[indices[0]];
      var p1 = transformed[indices[1]];
      var p2 = transformed[indices[2]];
      // Triangle normal
      var normal = getTriangleNormal(p0,p1,p2);
      // Triangle center
      var center = getCentroid(p0,p1,p2);
      // Direction vector from triangle to origin
      var vto = multiplyScalar(-1,center);
      return dotProduct(vto,normal) < 0;
    }
    //----------------------------------------------------------  --------------//
    //                         Lighting and shadows                           //
    //------------------------------------------------------------------------//

    function computeLighting(vertex, normal,  scene, specular) {
      var intensity = 0;
      for (i = 0 ; i<scene.lights.length; i++) {
        
        light = scene.lights[i];
        
        if (light.type == lightType.AMBIENT) {
    
          intensity += light.intensity;
          
        } else {
          var vl;
          if (light.type == lightType.POINT) {
            
            vl = subtractVectors(light.mat, vertexToVertex4(vertex));
          } else if (light.type == lightType.DIRECTIONAL){
            
            vl = light.vl;
          }
          // Diffuse light
          let nDotL = dotProduct(normal, vl);
          if (nDotL>0) {
            intensity += light.intensity * nDotL / (vectorLength(normal) * vectorLength(vl));
          }
          //Specular light
          if (specular != -1) {
            let vecR = subtractVectors(multiplyScalar(2.0*dotProduct(normal, vl), normal), vl);
            let view = subtractVectors(camera.position, vertex);
            let rDotV = dotProduct(vecR, view);
            if (rDotV > 0) {
              intensity += light.intensity * Math.pow(rDotV / (vectorLength(vecR) * vectorLength(view)), specular); 
            }
          }
          
        }
      }
      return intensity;
    }

    //------------------------------------------------------------------------//
    //                              Rendering                                 //
    //------------------------------------------------------------------------//

    function drawLine(p0, p1, color) {
        // Check if line is more horizontal than vertical
        if (Math.abs(p1.x-p0.x) > Math.abs(p1.y-p0.y)) {
          if (p0.x > p1.x) {
            var p =  p0;
            p0 = p1;
            p1 = p;
          }
          var yArray = interpolate(p0.x, p0.y, p1.x, p1.y);
          for (i = p0.x; i < p1.x; i++) {
            putPixel(i, yArray[i-p0.x],color);
          }
        } else {
          if (p0.y > p1.y) {
            var p =  p0;
            p0 = p1;
            p1 = p;
          }
          var xArray = interpolate(p0.y, p0.x, p1.y, p1.x);
          for (i = p0.y; i < p1.y; i++) {
            putPixel(xArray[i-p0.y], i, color);
          }
        }
    }
    function drawWireframeTriangle(p0,p1,p2, color) {
      drawLine(p0, p1, color);
      drawLine(p1, p2, color);
      drawLine(p2, p0, color);
    }
    function viewportToCanvas(x,y, canvas) {
      return new Point(parseInt(x*canvas.width/viewportWidth), parseInt(y*canvas.height/viewportHeight),1);
    }
    function canvasToViewport(x,y, canvas) {
      return new Point(x*viewportWidth/canvas.width, y*viewportHeight/canvas.height,1);
    }
    function projectVertex(v, canvas) {
      return viewportToCanvas(v.x*zProjectionPlane/v.z,v.y*zProjectionPlane/v.z, canvas);
    }
    function unProjectVertex(x,y,z,canvas) {
      x = x*z / zProjectionPlane;
      y = y*z / zProjectionPlane;
      var p = canvasToViewport(x,y, canvas);
      return new Vertex(p.x, p.y, z);
    }
    function renderTriangle(triangle, transformed, projected, instance, scene, canvas) {
      // Sorted indices
      var [i0,i1,i2] = sortIndices(triangle.indices, projected);
      // Transformed vertices
      var t0 = transformed[triangle.indices[i0]];
      var t1 = transformed[triangle.indices[i1]];
      var t2 = transformed[triangle.indices[i2]];
      // Projected vertices
      var p0 = projected[triangle.indices[i0]];
      var p1 = projected[triangle.indices[i1]];
      var p2 = projected[triangle.indices[i2]];
      // Vertex normals 
      var transform = multiplyMM(transpose(makeRotationMatrix(scene.camera.orientation)), makeRotationMatrix(instance.rotation));
      let n0 = arrayToVertex(multiplyMV(transform, vertexToVertex4(triangle.normals[i0])));
      var n1 = arrayToVertex(multiplyMV(transform, vertexToVertex4(triangle.normals[i1])));
      var n2 = arrayToVertex(multiplyMV(transform, vertexToVertex4(triangle.normals[i2])));
      //Interpolated normal vectors for Phong shading
      var [nx02, nx012] = interpolateEdges(p0.y, n0.x, p1.y, n1.x, p2.y, n2.x);
      var [ny02, ny012] = interpolateEdges(p0.y, n0.y, p1.y, n1.y, p2.y, n2.y);
      var [nz02, nz012] = interpolateEdges(p0.y, n0.z, p1.y, n1.z, p2.y, n2.z);
      // Points of the triangle edges
      var [x02, x012]   = interpolateEdges(p0.y,p0.x,p1.y,p1.x,p2.y,p2.x);
      var [iz02, iz012] = interpolateEdges(p0.y, 1.0/t0.z, p1.y, 1.0/t1.z, p2.y, 1.0/t2.z);
      // Determine left and right sides
      var m = parseInt(x012.length/2);
      if (x02[m] < x012[m]) {
        var [xLeft, xRight] = [x02, x012];
        var [izLeft, izRight] = [iz02, iz012];
        var [nxLeft, nxRight] = [nx02, nx012];
        var [nyLeft, nyRight] = [ny02, ny012];
        var [nzLeft, nzRight] = [nz02, nz012];
      } else {
        var [xLeft, xRight] = [x012, x02];
        var [izLeft, izRight] = [iz012, iz02];
        var [nxLeft, nxRight] = [nx012, nx02];
        var [nyLeft, nyRight] = [ny012, ny02];
        var [nzLeft, nzRight] = [nz012, nz02];
      }

      for (light of scene.lights) {
        if (light.type == lightType.DIRECTIONAL) {
          let mat =  makeRotationMatrix(scene.camera.orientation);
          light.vl = arrayToVertex(multiplyMV(mat, vertexToVertex4(light.direction)));
        } else if(light.type == lightType.POINT) {
          let cameraMat = makeCameraMatrix(camera);
          light.mat= arrayToVertex(multiplyMV(cameraMat, vertexToVertex4(light.position)));
        }
      }
      // Draw the segments
      for (y = p0.y, l1=p2.y; y <= l1; y++) {
        let xL = parseInt(xLeft[y-p0.y]);
        let xR = parseInt(xRight[y-p0.y]);
        let izSegment = interpolate(xL, izLeft[y - p0.y], xR, izRight[y - p0.y]);
        let nxSegment = interpolate(xL, nxLeft[y - p0.y], xR, nxRight[y - p0.y]);
        let nySegment = interpolate(xL, nyLeft[y - p0.y], xR, nyRight[y - p0.y]);
        let nzSegment = interpolate(xL, nzLeft[y - p0.y], xR, nzRight[y - p0.y]);
        for (x = xL, l2 = xR; x <= l2; x++) {
          let iz = izSegment[x - xL];
          if (updateDepthBuffer(x, y, iz, canvas)) {  
            var vertex = unProjectVertex(x, y, 1.0/iz, canvas);
            var normal = new Vertex(nxSegment[x - xL], nySegment[x - xL], nzSegment[x - xL]);
            var intensity = computeLighting(vertex, normal, scene, instance.reflectivity);
            putPixel(x,y,multiplyColor(intensity, triangle.color), canvas);
          }
        }
      }
    }
    function renderInstance(instance, scene, canvas) {
      var model = instance.model;
      var camera  = scene.camera;
      // Get the model matrix
      var modelMatrix = instance.makeTransformMatrix();
      // Get the camera matrix
      var cameraMatrix = makeCameraMatrix(camera);
      var transform = multiplyMM(cameraMatrix, modelMatrix);
      var transformed = [];

      for (let i = 0; i<model.vertices.length; i++) {
        let vecArray = multiplyMV(transform, vertexToVertex4(model.vertices[i]));
        transformed[i] = new Vertex(vecArray[0],vecArray[1],vecArray[2]);
      }
      var boundingSphere = getBoundingSphere(transformed);

      // Clip an entire model
 
      if (checkForClipping(boundingSphere, camera)) {
        return null;
      }
 
      var transformedModel = new Model(model.name, transformed, model.triangles);
 
      // Clip inidivudal triangles
      for (plane of camera.clippingPlanes) {
        transformedModel = clipModel(transformedModel, plane);
      }
      
      let projected = [];
      let newTransformed = transformedModel.vertices;
      for (v of newTransformed) {
        projected.push(projectVertex(v, canvas));
      }
   
      for (t of transformedModel.triangles) {
        if (!checkForCulling(transformed, t.indices)) {
          renderTriangle(t, transformed,projected, instance, scene, canvas);
        }
      }
    }
    function renderScene(scene, canvas) {
      for (i of scene.instances) {
        
        renderInstance(i,scene, canvas);
      }
    }
    //------------------------------------------------------------------------//
    //                            Event Handling                              //
    //------------------------------------------------------------------------//
    var cameraTranslate= new Vertex(0,0,0);
    var speed = 0.1;

    function triggerMoveCamera(event) {
      if(event.keyCode == 37) {
        cameraTranslate.x = -speed;
      }
      else if(event.keyCode == 38) {
        cameraTranslate.z = speed;
      }
      else if(event.keyCode == 39) {
        cameraTranslate.x = speed;
      }
      else if(event.keyCode == 40) {
        cameraTranslate.z = -speed;
      }
    }
    function releaseMoveCamera(event) {
      if(event.keyCode == 37) {
        cameraTranslate.x = 0;
      }
      else if(event.keyCode == 38) {
        cameraTranslate.z = 0;
      }
      else if(event.keyCode == 39) {
        cameraTranslate.x = 0;
      }
      else if(event.keyCode == 40) {
        cameraTranslate.z = 0;
      }
    }

    document.addEventListener('keydown', triggerMoveCamera, true);
    document.addEventListener('keyup', releaseMoveCamera, true);

    //------------------------------------------------------------------------//
    //                                 Main                                   //
    //------------------------------------------------------------------------//
    var cube_vertices = [
      new Vertex(1,1,1),   // 0
      new Vertex(-1,1,1),  // 1
      new Vertex(-1,-1,1), // 2
      new Vertex(1,-1,1),  // 3
      new Vertex(1,1,-1),  // 4
      new Vertex(-1,1,-1), // 5
      new Vertex(-1,-1,-1),// 6
      new Vertex(1,-1,-1)  // 7
    ];
    // Indices, normals, color
    var cube_triangles = [
      new Triangle([0,1,2], [new Vertex(0, 0, 1), new Vertex(0, 0, 1), new Vertex(0, 0, 1)], color.RED),
      new Triangle([0,2,3], [new Vertex(0, 0, 1), new Vertex(0, 0, 1), new Vertex(0, 0, 1)], color.RED),
      new Triangle([4,0,3], [new Vertex(1, 0, 0), new Vertex(1, 0, 0), new Vertex(1, 0, 0)], color.GREEN),
      new Triangle([4,3,7], [new Vertex(1, 0, 0), new Vertex(1, 0, 0), new Vertex(1, 0, 0)], color.GREEN),
      new Triangle([5,4,7], [new Vertex(0, 0, -1), new Vertex(0, 0, -1), new Vertex(0, 0, -1)], color.BLUE),
      new Triangle([5,7,6], [new Vertex(0, 0, -1), new Vertex(0, 0, -1), new Vertex(0, 0, -1)], color.BLUE),
      new Triangle([1,5,6], [new Vertex(-1, 0, 0), new Vertex(-1, 0, 0), new Vertex(-1, 0, 0)], color.YELLOW),
      new Triangle([1,6,2], [new Vertex(-1, 0, 0), new Vertex(-1, 0, 0), new Vertex(-1, 0, 0)], color.YELLOW),
      new Triangle([4,5,1], [new Vertex(0, 1, 0), new Vertex(0, 1, 0), new Vertex(0, 1, 0)], color.PURPLE),
      new Triangle([4,1,0], [new Vertex(0, 1, 0), new Vertex(0, 1, 0), new Vertex(0, 1, 0)], color.PURPLE),
      new Triangle([2,6,7], [new Vertex(0, -1, 0), new Vertex(0, -1, 0), new Vertex(0, -1, 0)], color.CYAN),
      new Triangle([2,7,3], [new Vertex(0, -1, 0), new Vertex(0, -1, 0), new Vertex(0, -1, 0)], color.CYAN)
    ];
    var plane_vertices = [
      new Vertex(1,0,1),   // 0
      new Vertex(-1,0,1),  // 1
      new Vertex(1,0,-1), // 2
      new Vertex(-1,0,-1),  // 3
    ]
    var plane_triangles = [
      new Triangle([2,3,1], [new Vertex(0, 1, 0), new Vertex(0, 1, 0), new Vertex(0, 1, 0)], color.RED),
      new Triangle([2,1,0], [new Vertex(0, 1, 0), new Vertex(0, 1, 0), new Vertex(0, 1, 0)], color.RED)
    ]
    var cube_model = new Model("Cube", cube_vertices, cube_triangles);
    var plane_model = new Model("Plane", plane_vertices, plane_triangles);
    var mainInstances = [
      new Instance(cube_model, new Vertex(-1.5, 0, 7),new Vertex(0, 0, 0) ,new Vertex(0.75, 0.75, 0.75), 1000),
      new Instance(cube_model, new Vertex(1.25, 2.5, 7.5),new Vertex(0, 180, 0), new Vertex(0.75, 0.75, 0.75), -1),
    ];
    var staticInstances = [
      new Instance(plane_model, new Vertex(0, -3, 7.5),new Vertex(0, 0, 0), new Vertex(10, 0, 10), -1),
    ]
    // #TODO Compute the planes normals for any fovs.
    var clippingPlanes = [
      new Plane(new Vertex(0, 0, 1), -zProjectionPlane), // Near
      new Plane(new Vertex(Math.sqrt(2) , 0, Math.sqrt(2)), 0), // Left
      new Plane(new Vertex(-Math.sqrt(2), 0, Math.sqrt(2)), 0), // Right
      new Plane(new Vertex(0, -Math.sqrt(2), Math.sqrt(2)), 0), // Top
      new Plane(new Vertex(0, Math.sqrt(2),Math.sqrt(2)), 0),
    ];
    // Position, rotation, clipping planes
    var camera = new Camera(new Vertex(0, 0, 0), new Vertex(0, 0, 0), clippingPlanes);
    // type, intensity, position, direction
    var lights = [
      new Light(lightType.AMBIENT, 0.2),
      new Light(lightType.DIRECTIONAL, 0.6, null, new Vertex(3,3,-3)),
      new Light(lightType.POINT, 0.4, new Vertex(0, -2, 8))
    ];
    var mainScene = new Scene(mainInstances , camera, lights);
    var staticScene = new Scene(staticInstances , camera, lights);
    // Limiting frame rate to 60 fps
    var stop = false;
    var frameCount = 0;
    var fps =  40;
    var fpsInterval, startTime, now, then, elapsed;

    fpsInterval = 1000 / fps;
    then = Date.now();
    startTime = then;

    function gameLoop() {
      requestAnimationFrame(gameLoop);
      now = Date.now();
      elapsed = now - then;
      if (elapsed > fpsInterval) {
        then = now - (elapsed % fpsInterval);
        clearBuffers(mainCanvas);
        
        mainScene.instances[0].rotation.x += 2;
        mainScene.instances[0].rotation.z += 2;
        mainScene.camera.translate(cameraTranslate);
        mainCanvas.context.drawImage(offScreenCanvas.element, 0, 0);  
        mainCanvas.buffer = mainCanvas.context.getImageData(0, 0, canvas.width, canvas.height);
        renderScene(mainScene,mainCanvas);
        updateCanvas(mainCanvas);
        
        
      }
    }
    
    function render() {
      renderScene(staticScene,offScreenCanvas);
      updateCanvas(offScreenCanvas);
      gameLoop();
    }
    render();
  </script>
</canvas>
</html>
