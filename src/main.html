<!DOCTYPE html>
<html>
<head>
<title>HTML Rasterizer</title>
</head>
<body>
<canvas id="canvas" width="600" height="600" style="border: 1px grey solid">
  <script>
    //------------------------------------------------------------------------//
    //                            Canvas Data                                 //
    //------------------------------------------------------------------------//
    var canvas = document.getElementById("canvas");
    var canvasContext = canvas.getContext("2d");
    var canvasBuffer = canvasContext.getImageData(0, 0, canvas.width, canvas.height);
    var canvasPitch = canvasBuffer.width * 4;

    var viewportWidth = 1;
    var viewportHeight = 1;

    // Distance between near plane and origin
    var zProjectionPlane = 1;
    // To store depth of pixels to be drawn
    var depthBuffer = [];

    function putPixel(x, y, color) {
      x = canvas.width/2 + Math.floor(x);
      y = canvas.height/2 - Math.floor(y) - 1;
      if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
        return;
      }
      var offset = 4*x + canvasPitch*y;
      canvasBuffer.data[offset++] = color[0];
      canvasBuffer.data[offset++] = color[1];
      canvasBuffer.data[offset++] = color[2];
      canvasBuffer.data[offset++] = 255;
    }
    function updateCanvas() {
      canvasContext.putImageData(canvasBuffer, 0, 0);
    }
    function clearBuffers() {
      canvasContext.clearRect(0, 0, canvas.width, canvas.height);
      canvasBuffer = canvasContext.getImageData(0, 0, canvas.width, canvas.height);
      depthBuffer = [];
    }
    //------------------------------------------------------------------------//
    //                                Colors                                  //
    //------------------------------------------------------------------------//
    const RED = [255, 0, 0];
    const GREEN = [0, 255, 0];
    const BLUE = [0, 0, 255];
    const YELLOW = [255, 255, 0];
    const PURPLE = [255, 0, 255];
    const CYAN = [0, 255, 255];
    //------------------------------------------------------------------------//
    //                                Classes                                 //
    //------------------------------------------------------------------------//
    // 2D Point
    class Point {
      constructor(x,y,h) {
        this.x=x;
        this.y=y;
        this.h=h;
      }
    }
    // 3D Vertex
    class Vertex {
      constructor(x,y,z) {
        this.x=x;
        this.y=y;
        this.z=z;
      }
      toString() {
        return "<" + this.x + ", " + this.y + ", " + this.z + ">" ;
      }
    }
    // 3D Vertex with homogeneous coordinate
    class Vertex4 {
      constructor(x,y,z,w) {
        this.x=x;
        this.y=y;
        this.z=z;
        this.w=w;
      }
      toArray() {
        let a = [this.x,this.y,this.z,this.w];
        return a;
      }
    }
    // 4x4 matrix
    class Mat {
      constructor(values) {
        this.values = values;
      }
    }
    class Triangle {
      constructor(indices,color) {
        this.indices = indices;
        this.color = color;
      }
    }
    class Scene {
      constructor(instances) {
        this.instances = instances;
      }
    }
    class Model {
      constructor(name,vertices,triangles) {
        this.name=name;
        this.vertices=vertices;
        this.triangles=triangles;
      }
    }
    class Instance {
      constructor(model,position,rotation,scaling) {
        this.model=model;
        this.position = position;
        this.rotation = rotation;
        this.scaling = scaling;
      }
      makeTransformMatrix() {
        let translationMat = makeTranslationMatrix(this.position);
        let rotationMat = makeYRotationMatrix(this.rotation.y);
        let scaleMat = makeScaleMatrix(this.scaling);
        let mat = multiplyMM(rotationMat,scaleMat);
        return multiplyMM(translationMat,mat);
      }
    }
    class Camera {
      constructor(position, orientation, clippingPlanes) {
        this.position = position;
        this.orientation = orientation;
        this.clippingPlanes = clippingPlanes
      }
      translate (vector) {
        this.position.x += vector.x;
        this.position.y += vector.y;
        this.position.z += vector.z;
      }
    }
    class Plane {
      constructor(normal, distance) {
        this.normal = normal;
        // distance from origin to plane. Same thing as D in plane equation.
        this.distance = distance;
      }
    }
    class BoundingSphere {
      constructor(position,radius) {
        this.position = position;
        this.radius = radius;
      }
    }
    //------------------------------------------------------------------------//
    //                     Linear algebra and helpers                         //
    //------------------------------------------------------------------------//
    // Add two vectors
    function addVectors(vec1, vec2) {
      return new Vertex(vec1.x + vec2.x, vec1.y + vec2.y, vec1.z + vec2.z);
    }
    // Multiply a vector by a scalar
    function multiplyScalar(s,vec) {
      return new Vertex(s*vec.x, s*vec.y, s*vec.z);
    }
    // Dot product between two vectors
    function dotProduct(vec1, vec2) {
      return vec1.x*vec2.x + vec1.y * vec2.y + vec1.z * vec2.z;
    }
    // Cross product between two vectors
    function crossProduct(vec1, vec2) {
      let i = vec1.y * vec2.z - vec1.z * vec2.y;
      let j = vec1.x * vec2.z - vec1.z * vec2.x;
      let k = vec1.x * vec2.y - vec1.y * vec2.x;
      return new Vertex(i, -j, k);
    }
    // Distance between two points.
    function distancePoints(p1,p2) {
      let d = Math.pow(p2.x-p1.x,2) + Math.pow(p2.y-p1.y,2)
      if (typeof p1.z != "undefined" && typeof p2.z != "undefined") {
        d += Math.pow(p2.z-p1.z,2)
      }
      return Math.sqrt(d);
    }
    // Mid point between two points.
    function midPoint(p1,p2) {
      let x = parseInt((p1.x+p2.x)/2);
      let y = parseInt((p1.y+p2.y)/2);
      if (typeof p1.z != "undefined" && typeof p2.z != "undefined") {
        let z = parseInt((p1.z+p2.z)/2);
        return new Vertex(x,y,z);
      } else {
        return new Point(x,y);
      }
    }

    // Return the transpose of the given matrix
    function transpose(mat) {
      let result = [];
      let values = mat.values;
      for (i=0;i<values.length;i++) {
        result[i]=[];
        for(j=0;j<values[0].length;j++) {
          result[i][j]=values[j][i];
        }
      }
      return new Mat(result);
    }
    // Multiply a matrix by a vector.
    function multiplyMV(mat,vec) {
      let v = vec.toArray();
      if (mat.values[0].length!=v.length) {
        return null;
      }

      let result=[];
      for (i=0;i<v.length;i++) {
        result.push(0);
      }
      let values = mat.values;

      for (i=0; i<values.length; i++) {
        for (j=0; j<values[i].length; j++) {
          result[i] += values[i][j] * v[j];
        }
      }
      return result;
    }
    // Multiply a matrix by another matrix
    function multiplyMM(mat1,mat2) {
      mat1Data = mat1.values;
      mat2Data = mat2.values;
      if (mat1Data[0].length!=mat2Data.length) {
        return null;
      }
      let result = [];
      for (i=0;i<mat1Data.length;i++) {
        result[i]=[];
        for(j=0;j<mat2Data[0].length;j++) {
          result[i][j]=0;
        }
      }
      for (i=0; i<mat1Data.length; i++) {
        for (j=0; j<mat2Data[i].length; j++){
          let dot=0;
          for (k=0; k<mat1Data[i].length; k++){
            dot+= mat1Data[i][k] * mat2Data[k][j];
          }
          result[i][j] = dot;
        }
      }
      return new Mat(result);
    }
    function vertexToVertex4(vertex){
      return new Vertex4(vertex.x,vertex.y,vertex.z,1);
    }
    function interpolate(x0,y0,x1,y1) {
      if (x0==x1){
        return [ y0 ];
      }
      var values = [];
      var a = (y1-y0) / (x1-x0);
      var y = y0;
      for (i = x0; i <= x1; i++) {
        values.push(y);
        y=y+a;
      }
      return values;
    }
    function interpolateEdges(x0,y0,x1,y1,x2,y2) {
      var y01 = interpolate(x0,y0,x1,y1);
      var y12 = interpolate(x1,y1,x2,y2);
      var y02 = interpolate(x0,y0,x2,y2);
      y01.pop();
      var y012 = y01.concat(y12);
      return [y02, y012];
    }
    // Get the normal of a triangle
    function getTriangleNormal(v0,v1,v2){
      let v01 = addVectors(v1, multiplyScalar(-1,v0));
      let v02 = addVectors(v2, multiplyScalar(-1,v0));
      return crossProduct(v01,v02);
    }
    // Find the centroid of a triangle
    function getCentroid(v0,v1,v2) {
      return multiplyScalar(1/3, addVectors(addVectors(v0, v1), v2));
    }
    // Find the point where the line defined by a and b intersect the plane
    function planeIntersection(a,b, plane) {
      let bMinusA = addVectors(b, multiplyScalar(-1, a));
      let num = - plane.distance - dotProduct(plane.normal, a);
      let denum = dotProduct(plane.normal, bMinusA);
      return addVectors(a, multiplyScalar(num/denum, bMinusA));
    }
    function sortVertices(p0,p1,p2) {
      // p0.y <= p1.y <= p2.y
      if (p1.y<p0.y) {
        var p =  p0;
        p0 = p1;
        p1 = p;
      }
      if (p2.y<p0.y) {
        var p =  p0;
        p0 = p2;
        p2 = p;
      }
      if (p2.y<p1.y) {
        var p =  p1;
        p1 = p2;
        p2 = p;
      }
      return [p0,p1,p2];
    }
    clearBuffers()
    //------------------------------------------------------------------------//
    //                        Transformation Matrices                         //
    //------------------------------------------------------------------------//

    // Translation matrix to the given position vector
    function makeTranslationMatrix(position) {
      let m = [
        [1,0,0,position.x],
        [0,1,0,position.y],
        [0,0,1,position.z],
        [0,0,0,1]
      ];
      return new Mat(m);
    }
    // Scale matrix for the given scaling vector
    function makeScaleMatrix(scaling) {
      let m = [
        [scaling.x,0,0,0],
        [0,scaling.y,0,0],
        [0,0,scaling.z,0],
        [0,0,0,1]
      ];
      return new Mat(m);
    }
    // Rotation matrix around y by the given angle (in degrees)
    function makeYRotationMatrix(angle) {
      let rad = angle*Math.PI/180;
      let m = [
        [Math.cos(rad),0,Math.sin(rad),0],
        [0,1,0,0],
        [-Math.sin(rad),0,Math.cos(rad),0],
        [0,0,0,1]
      ];
      return new Mat(m);
    }
    // Rotation matrix around x by the given angle (in degrees)
    function makeXRotationMatrix(angle) {
      let rad = angle*Math.PI/180;
      let m = [
        [1,0,0,0],
        [0,Math.cos(rad),-Math.sin(rad),0],
        [0,Math.sin(rad),Math.cos(rad),0],
        [0,0,0,1]
      ];
      return new Mat(m);
    }
    function makeCameraMatrix(camera){
      let yRotationMat = transpose(makeYRotationMatrix(camera.orientation.y));
      let xRotationMat = transpose(makeXRotationMatrix(camera.orientation.x));
      let rotationMat = multiplyMM(xRotationMat,yRotationMat);
      let translationMat = makeTranslationMatrix(multiplyScalar(-1,camera.position));
      return multiplyMM(rotationMat,translationMat);
    }

    //------------------------------------------------------------------------//
    //                               Clipping                                 //
    //------------------------------------------------------------------------//

    // Get the bounding sphere of an array of vertices based on Ritter's algorithm.
    function getBoundingSphere(vertices) {
      var x = vertices[0];
      var y = vertices[0];
      var d = 0;
      for (let v of vertices) {
        let d2 = distancePoints(x,v);
        if (d2 > d) {
          d = d2;
          y = v;
        }
      }
      let z = vertices[0];
      for (let v of vertices) {
        let d2 = distancePoints(y,v);
        if (d2 > d) {
          d = d2;
          z = v;
        }
      }
      let mid = midPoint(z,y);
      let radius = d/2;
      let expandRadius = false;
      for (let v of vertices) {
        let d2 = distancePoints(mid,v);
        if (d2>radius) {
          radius = d2;
        }
      }
      return new BoundingSphere(mid,radius);
    }
    // Checks if the bounding sphere is inside the view frustum defined by the camera.
    function checkForClipping(sphere, camera) {
      for (p of camera.clippingPlanes) {
        let d = dotProduct(p.normal, sphere.position) + p.distance;
        if (d < -sphere.radius) {
          return true;
        }
      }
      return false;
    }
    // Clip the individual triangles in the model.
    // #TODO Implement the recalculation of additional vertices attributes.
    function clipModel(model, plane) {
      var newTriangles = [];
      var newVertices = model.vertices;
      for (let triangle of model.triangles) {
        let iIn = [];
        let iOut = [];

        for (i = 0; i<triangle.indices.length; i++) {
          let v = newVertices[triangle.indices[i]];
          if (dotProduct(plane.normal, v) + plane.distance > 0) {
            iIn.push(triangle.indices[i]);
          } else {
            iOut.push(triangle.indices[i]);
          }
        }
        if (iIn.length == 0) {
          // Do nothing
        } else if (iIn.length == 3) {
          newTriangles.push(triangle);
        } else if (iIn.length == 1) {
          let newIndices = [0,0,0];
          let q1 = planeIntersection(iIn[0],iOut[0], plane);
          let q2 = planeIntersection(iIn[0],iOut[1], plane);
          newIndices[0] = newVertices.length;
          newVertices.push(q1);
          newIndices[1] = newVertices.length;
          newVertices.push(q2);
          newIndices[2] = iIn[0];
          newTriangles.push(new Triangle(newIndices, triangle.color));
        } else if (iIn.length == 2) {
          let newIndices = [0,0,0];
          let q1 = planeIntersection(iIn[0],iOut[0], plane);
          newIndices[0] = newVertices.length;
          newVertices.push(q1);
          newIndices[1] = iIn[0];
          newIndices[2] = iIn[1];
          newTriangles.push(new Triangle(newIndices, triangle.color));
          let q2 = planeIntersection(iIn[1],iOut[0], plane);
          newIndices[1] = newVertices.length;
          newVertices.push(q2);
          newIndices[2] = iIn[1];
          newTriangles.push(new Triangle(newIndices, triangle.color));
        }
      }
      return new Model(model.name, newVertices, newTriangles);
    }
    //------------------------------------------------------------------------//
    //                            Depth testing                               //
    //------------------------------------------------------------------------//

    function updateDepthBuffer(x, y, zInv) {
      var x = canvas.width/2 + Math.floor(x);
      var y = canvas.height/2 - Math.floor(y) - 1;
      if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
        return;
      }
      var offset = x + canvas.width*y;
      if (depthBuffer[offset] == undefined || depthBuffer[offset] < zInv) {
        depthBuffer[offset] = zInv;
        return true;
      }
      return false;
    }
    //------------------------------------------------------------------------//
    //                            Backface culling                            //
    //------------------------------------------------------------------------//
    function checkForCulling(p0,p1,p2) {
      // Triangle normal
      var normal = getTriangleNormal(p0,p1,p2);
      // Triangle center
      var center = getCentroid(p0,p1,p2);
      // Direction vector from triangle to origin
      var vto = multiplyScalar(-1,center);
      return dotProduct(vto,normal) < 0;
    }
    //------------------------------------------------------------------------//
    //                              Rendering                                 //
    //------------------------------------------------------------------------//

    function drawLine(p0, p1, color) {
        // Check if line is more horizontal than vertical
        if (Math.abs(p1.x-p0.x) > Math.abs(p1.y-p0.y)) {
          if (p0.x > p1.x) {
            var p =  p0;
            p0 = p1;
            p1 = p;
          }
          var yArray = interpolate(p0.x, p0.y, p1.x, p1.y);
          for (i = p0.x; i < p1.x; i++) {
            putPixel(i, yArray[i-p0.x],color);
          }
        } else {
          if (p0.y > p1.y) {
            var p =  p0;
            p0 = p1;
            p1 = p;
          }
          var xArray = interpolate(p0.y, p0.x, p1.y, p1.x);
          for (i = p0.y; i < p1.y; i++) {
            putPixel(xArray[i-p0.y], i, color);
          }
        }
    }
    function drawWireframeTriangle(p0,p1,p2, color) {
      drawLine(p0, p1, color);
      drawLine(p1, p2, color);
      drawLine(p2, p0, color);
    }
    function viewportToCanvas(x,y) {
      return new Point(parseInt(x*canvas.width/viewportWidth), parseInt(y*canvas.height/viewportHeight),1);
    }
    function projectVertex(v) {
      return viewportToCanvas(v.x*zProjectionPlane/v.z,v.y*zProjectionPlane/v.z);
    }
    function renderTriangle(triangle, transformed, projected) {
      // Transformed vertices
      var t0 = transformed[triangle.indices[0]];
      var t1 = transformed[triangle.indices[1]];
      var t2 = transformed[triangle.indices[2]];
      if (checkForCulling(t0,t1,t2)) {
        return null;
      }
      [t0,t1,t2] = sortVertices(t0,t1,t2);
      // Projected vertices
      var p0 = projected[triangle.indices[0]];
      var p1 = projected[triangle.indices[1]];
      var p2 = projected[triangle.indices[2]];

      [p0,p1,p2] = sortVertices(p0,p1,p2);

      // Points of the triangle edges
      var [x02, x012] = interpolateEdges(p0.y,p0.x,p1.y,p1.x,p2.y,p2.x);
      var [iz02, iz012] = interpolateEdges(p0.y, 1.0/t0.z, p1.y, 1.0/t1.z, p2.y, 1.0/t2.z);
      // Determine left and right sides
      var m = parseInt(x012.length/2);
      var xLeft, xRight, izLeft, izRight;
      if (x02[m] < x012[m]) {
        xLeft = x02;
        xRight = x012;
        izLeft = iz02;
        izRight = iz012;
      } else {
        xLeft = x012;
        xRight = x02;
        izLeft = iz012;
        izRight = iz02;
      }
      // Draw the segments
      for (y = p0.y; y <= p2.y; y++) {
        let xL = parseInt(xLeft[y-p0.y]);
        let xR = parseInt(xRight[y-p0.y]);
        let izSegment = interpolate(xL, izLeft[y - p0.y], xR, izRight[y - p0.y]);
        for (x = xL; x <= xR; x++) {
          if (updateDepthBuffer(x, y, izSegment[x - xL])) {
            putPixel(x,y,triangle.color);
          }
        }
      }
    }
    function renderInstance(instance, camera) {
      var model = instance.model;

      // Get the model matrix
      var modelMatrix = instance.makeTransformMatrix();
      // Get the camera matrix
      var cameraMatrix = makeCameraMatrix(camera);
      var transform = multiplyMM(cameraMatrix, modelMatrix);
      var transformed = [];

      for (let i = 0; i<model.vertices.length; i++) {
        let vecArray = multiplyMV(transform, vertexToVertex4(model.vertices[i]));
        transformed[i] = new Vertex(vecArray[0],vecArray[1],vecArray[2]);
      }
      var boundingSphere = getBoundingSphere(transformed);

      // Clip an entire model
      if (checkForClipping(boundingSphere, camera)) {
        return null;
      }
      var transformedModel = new Model(model.name, transformed, model.triangles);
      // Clip inidivudal triangles
      for (plane of camera.clippingPlanes) {
        transformedModel = clipModel(transformedModel, plane);
      }

      let projected = [];

      for (v of transformedModel.vertices) {
        projected.push(projectVertex(v));
      }
      for (t of transformedModel.triangles) {
        renderTriangle(t,transformed,projected);
      }
    }
    function renderScene(scene,camera) {
      for (i of scene.instances) {
        renderInstance(i,camera);
      }
    }
    //------------------------------------------------------------------------//
    //                            Event Handling                              //
    //------------------------------------------------------------------------//
    var cameraTranslate= new Vertex(0,0,0);
    var speed = 0.1;

    function triggerMoveCamera(event) {
      if(event.keyCode == 37) {
        cameraTranslate.x = -speed;
      }
      else if(event.keyCode == 38) {
        cameraTranslate.z = speed;
      }
      else if(event.keyCode == 39) {
        cameraTranslate.x = speed;
      }
      else if(event.keyCode == 40) {
        cameraTranslate.z = -speed;
      }
    }
    function releaseMoveCamera(event) {
      if(event.keyCode == 37) {
        cameraTranslate.x = 0;
      }
      else if(event.keyCode == 38) {
        cameraTranslate.z = 0;
      }
      else if(event.keyCode == 39) {
        cameraTranslate.x = 0;
      }
      else if(event.keyCode == 40) {
        cameraTranslate.z = 0;
      }
    }

    document.addEventListener('keydown', triggerMoveCamera, true);
    document.addEventListener('keyup', releaseMoveCamera, true);

    //------------------------------------------------------------------------//
    //                                 Main                                   //
    //------------------------------------------------------------------------//
    var cube_vertices = [
      new Vertex(1,1,1),   // 0
      new Vertex(-1,1,1),  // 1
      new Vertex(-1,-1,1), // 2
      new Vertex(1,-1,1),  // 3
      new Vertex(1,1,-1),  // 4
      new Vertex(-1,1,-1), // 5
      new Vertex(-1,-1,-1),// 6
      new Vertex(1,-1,-1)  // 7
    ];
    var cube_triangles = [
      new Triangle([0,1,2],RED),
      new Triangle([0,2,3],RED),
      new Triangle([4,0,3],GREEN),
      new Triangle([4,3,7],GREEN),
      new Triangle([5,4,7],BLUE),
      new Triangle([5,7,6],BLUE),
      new Triangle([1,5,6],YELLOW),
      new Triangle([1,6,2],YELLOW),
      new Triangle([4,5,1],PURPLE),
      new Triangle([4,1,0],PURPLE),
      new Triangle([2,6,7],CYAN),
      new Triangle([2,7,3],CYAN)
    ];
    var cube_model = new Model("Cube", cube_vertices, cube_triangles);
    var instances = [];
    // position, rotation, scaling
    var cube1 = new Instance(cube_model, new Vertex(-1.5, 0, 5),new Vertex(0, 0, 0),new Vertex(0.75, 0.75, 0.75));
    instances.push(cube1);
    var cube2 = new Instance(cube_model, new Vertex(1.5, 0, 7),new Vertex(0, 0, 0),new Vertex(1, 1, 1));
    instances.push(cube2);

    var scene = new Scene(instances);

    // #TODO Compute the planes normals for any fovs.
    var clippingPlanes = [
      new Plane(new Vertex(0, 0, 1), -zProjectionPlane), // Near
      new Plane(new Vertex(Math.sqrt(2) , 0, Math.sqrt(2)), 0), // Left
      new Plane(new Vertex(-Math.sqrt(2), 0, Math.sqrt(2)), 0), // Right
      new Plane(new Vertex(0, -Math.sqrt(2), Math.sqrt(2)), 0), // Top
      new Plane(new Vertex(0, Math.sqrt(2),Math.sqrt(2)), 0),
    ];
    // Position, rotation, clipping planes
    var camera = new Camera(new Vertex(0, 0, 0), new Vertex(0, 0, 0), clippingPlanes);

    function gameLoop() {
      clearBuffers();
      instances[1].rotation.y +=2;
      camera.translate(cameraTranslate);
      renderScene(scene,camera);
      updateCanvas();
      requestAnimationFrame(gameLoop);
    }

    requestAnimationFrame(gameLoop);
  </script>
</canvas>
</html>
